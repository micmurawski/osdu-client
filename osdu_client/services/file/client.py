from __future__ import annotations

import requests

from osdu_client.exceptions import OSDUAPIError
from osdu_client.services.base import OSDUAPIClient
from osdu_client.utils import urljoin
from osdu_client.validation import validate_data

from .models import DeliveryGetFileSignedURLRequest, FileListRequest, FileLocationRequest, LocationRequest, Record


class FileAPIError(OSDUAPIError):
    pass


class FileClient(OSDUAPIClient):
    service_path = ""

    def get_location(
        self, *, file_id: str | None = None, data_partition_id: str | None = None
    ) -> dict:
        """
            Create a new location in the landing zone to upload a file.

        **Required roles**: 'users.datalake.editors' or 'users.datalake.admins' or 'users.datalake.ops'.

            Args:
                data_partition_id (str): identifier of the data partition to query. If None sets by auth session.
                file_id (str):
            Returns:
                response data (dict)
            Raises:
                OSDUValidation: if request values are wrong.
                OSDUAPIError: if response is 4XX or 5XX
        """
        headers = self.auth.get_headers()
        if data_partition_id:
            headers["data-partition-id"] = data_partition_id

        request_data = {}
        if file_id is not None:
            request_data["FileID"] = file_id

        if self.validation:
            validate_data(request_data, LocationRequest)

        url = urljoin(self.base_url, self.service_path, "v2/getLocation")
        response = requests.post(url, headers=headers, json=request_data)
        if not response.ok:
            raise FileAPIError(response.text, response.status_code)
        return response.json()

    def get_files_upload_url(self, data_partition_id: str | None = None) -> dict:
        """
            Gets a temporary signed URL to upload a file.The generated URL is time bound and expires after 24 hours.

        User will receive a FileSource in the response.This is the relative path where the uploaded file will persist.
        Once the file is uploaded, FileSource can then be used to post metadata of the file. The uploaded file gets automatically deleted, if the metadata is not posted within 24 hours of uploading the file.


        **Required roles**: 'users.datalake.viewers' or 'users.datalake.editors' or 'users.datalake.admins' or 'users.datalake.ops'.
            Args:
                data_partition_id (str): identifier of the data partition to query. If None sets by auth session.
            Returns:
                response data (dict)
            Raises:
                OSDUValidation: if request values are wrong.
                OSDUAPIError: if response is 4XX or 5XX
        """
        headers = self.auth.get_headers()
        if data_partition_id:
            headers["data-partition-id"] = data_partition_id

        url = urljoin(self.base_url, self.service_path, "v2/files/uploadURL")
        response = requests.get(url, headers=headers)
        if not response.ok:
            raise FileAPIError(response.text, response.status_code)
        return response.json()

    def create_files_metadata(
        self,
        *,
        kind: str,
        acl: dict,
        legal: dict,
        data: dict,
        id: str | None = None,
        ancestry: dict | None = None,
        data_partition_id: str | None = None,
    ) -> dict:
        """
            This API creates a metadata record for a file that is already uploaded. The Metadata is linked to the file via `FileSource` provided in the request body.

        If `FileSource` attribute is missing in the request body or there is no file present, then the request fails with an error.

        When metadata is successfully updated in the system, it returns the `Id` of the file metadata record.

        **Required roles**: 'users.datalake.viewers' or 'users.datalake.editors' or 'users.datalake.admins' or 'users.datalake.ops'.
            Args:
                data_partition_id (str): identifier of the data partition to query. If None sets by auth session.
                kind (str): Kind of data being ingested. Must follow the naming convention:data-Partition-Id}:dataset-name}:record-type}:version}.
                acl (dict):
                legal (dict):
                data (dict):
                id (str): Unique identifier generated by the system for the file metadata record.
                ancestry (dict):
            Returns:
                response data (dict)
            Raises:
                OSDUValidation: if request values are wrong.
                OSDUAPIError: if response is 4XX or 5XX
        """
        headers = self.auth.get_headers()
        if data_partition_id:
            headers["data-partition-id"] = data_partition_id

        request_data = {
            "kind": kind,
            "acl": acl,
            "legal": legal,
            "data": data,
        }
        if id is not None:
            request_data["id"] = id
        if ancestry is not None:
            request_data["ancestry"] = ancestry

        if self.validation:
            validate_data(request_data, Record)

        url = urljoin(self.base_url, self.service_path, "v2/files/metadata")
        response = requests.post(url, headers=headers, json=request_data)
        if not response.ok:
            raise FileAPIError(response.text, response.status_code)
        return response.json()

    def get_files_metadata(
        self, *, id: str, data_partition_id: str | None = None
    ) -> dict:
        """
            Gets the latest version of File metadata record identified by the given id.

        **Required roles**: 'users.datalake.viewers' or 'users.datalake.editors' or 'users.datalake.admins' or 'users.datalake.ops'.
            Args:
                data_partition_id (str): identifier of the data partition to query. If None sets by auth session.
                id (str): File metadata record Id.
            Returns:
                response data (dict)
            Raises:
                OSDUValidation: if request values are wrong.
                OSDUAPIError: if response is 4XX or 5XX
        """
        headers = self.auth.get_headers()
        if data_partition_id:
            headers["data-partition-id"] = data_partition_id

        url = urljoin(self.base_url, self.service_path, "v2/files/%s/metadata" % id)
        response = requests.get(url, headers=headers)
        if not response.ok:
            raise FileAPIError(response.text, response.status_code)
        return response.json()

    def delete_files_metadata(
        self, *, id: str, data_partition_id: str | None = None
    ) -> dict:
        """
          Deletes the File metadata record identified by the given id and file associated with that metadata record.

        **Required roles**: 'users.datalake.editors'  or 'users.datalake.admins'.
          Args:
              data_partition_id (str): identifier of the data partition to query. If None sets by auth session.
              id (str): File metadata record Id.
          Returns:
              response data (dict)
          Raises:
              OSDUValidation: if request values are wrong.
              OSDUAPIError: if response is 4XX or 5XX
        """
        headers = self.auth.get_headers()
        if data_partition_id:
            headers["data-partition-id"] = data_partition_id

        url = urljoin(self.base_url, self.service_path, "v2/files/%s/metadata" % id)
        response = requests.delete(url, headers=headers)
        if not response.ok:
            raise FileAPIError(response.text, response.status_code)
        return response.json()

    def gets_url_to_download_file(
        self,
        *,
        id: str,
        expiry_time: str | None = None,
        data_partition_id: str | None = None,
    ) -> dict:
        """
            Gets a URL for downloading the file associated with the unique `id`.

        **Required roles**: 'users.datalake.viewers' or 'users.datalake.editors' or 'users.datalake.admins' or 'users.datalake.ops'.
            Args:
                data_partition_id (str): identifier of the data partition to query. If None sets by auth session.
                id (str): File Metadata record Id.
                expiry_time (str): The Time for which Signed URL to be valid. Accepted Regex patterns are "^[0-9]+M$", "^[0-9]+H$", "^[0-9]+D$" denoting Integer values in Minutes, Hours, Days respectively. In absence of this parameter the URL would be valid for 7 Days.
            Returns:
                response data (dict)
            Raises:
                OSDUValidation: if request values are wrong.
                OSDUAPIError: if response is 4XX or 5XX
        """
        headers = self.auth.get_headers()
        if data_partition_id:
            headers["data-partition-id"] = data_partition_id

        params = {}
        if expiry_time is not None:
            params["expiryTime"] = expiry_time

        url = urljoin(self.base_url, self.service_path, "v2/files/%s/downloadURL" % id)
        response = requests.get(url, headers=headers, params=params)
        if not response.ok:
            raise FileAPIError(response.text, response.status_code)
        return response.json()

    def get_file_location(
        self, *, file_id: str | None = None, data_partition_id: str | None = None
    ) -> dict:
        """
        Returns file `Location` and `Driver`.

        Args:
            data_partition_id (str): identifier of the data partition to query. If None sets by auth session.
            file_id (str):
        Returns:
            response data (dict)
        Raises:
            OSDUValidation: if request values are wrong.
            OSDUAPIError: if response is 4XX or 5XX
        """
        headers = self.auth.get_headers()
        if data_partition_id:
            headers["data-partition-id"] = data_partition_id

        request_data = {}
        if file_id is not None:
            request_data["FileID"] = file_id

        if self.validation:
            validate_data(request_data, FileLocationRequest)

        url = urljoin(self.base_url, self.service_path, "v2/getFileLocation")
        response = requests.post(url, headers=headers, json=request_data)
        if not response.ok:
            raise FileAPIError(response.text, response.status_code)
        return response.json()

    def get_file_signed_url(
        self, *, srn: list[str] | None = None, data_partition_id: str | None = None
    ) -> dict:
        """
        Returns delivery instructions for File(s) using SRNs

        Args:
            data_partition_id (str): identifier of the data partition to query. If None sets by auth session.
            srn (list[str]): A list of SRNs to fetch
        Returns:
            response data (dict)
        Raises:
            OSDUValidation: if request values are wrong.
            OSDUAPIError: if response is 4XX or 5XX
        """
        headers = self.auth.get_headers()
        if data_partition_id:
            headers["data-partition-id"] = data_partition_id

        request_data = {}
        if srn is not None:
            request_data["srn"] = srn

        if self.validation:
            validate_data(request_data, DeliveryGetFileSignedURLRequest)

        url = urljoin(self.base_url, self.service_path, "v2/delivery/getFileSignedUrl")
        response = requests.post(url, headers=headers, json=request_data)
        if not response.ok:
            raise FileAPIError(response.text, response.status_code)
        return response.json()

    def get_file_list(
        self,
        *,
        time_from: str | None = None,
        time_to: str | None = None,
        page_num: int | None = None,
        items: int | None = None,
        user_id: str | None = None,
        data_partition_id: str | None = None,
    ) -> dict:
        """
        Allows the application to audit the attempted file uploads. The method is internal and isn't available for third-party applications.

        Args:
            data_partition_id (str): identifier of the data partition to query. If None sets by auth session.
            time_from (str):
            time_to (str):
            page_num (int):
            items (int):
            user_id (str):
        Returns:
            response data (dict)
        Raises:
            OSDUValidation: if request values are wrong.
            OSDUAPIError: if response is 4XX or 5XX
        """
        headers = self.auth.get_headers()
        if data_partition_id:
            headers["data-partition-id"] = data_partition_id

        request_data = {}
        if time_from is not None:
            request_data["TimeFrom"] = time_from
        if time_to is not None:
            request_data["TimeTo"] = time_to
        if page_num is not None:
            request_data["PageNum"] = page_num
        if items is not None:
            request_data["Items"] = items
        if user_id is not None:
            request_data["UserID"] = user_id

        if self.validation:
            validate_data(request_data, FileListRequest)

        url = urljoin(self.base_url, self.service_path, "v2/getFileList")
        response = requests.post(url, headers=headers, json=request_data)
        if not response.ok:
            raise FileAPIError(response.text, response.status_code)
        return response.json()

    def get_info(self, data_partition_id: str | None = None) -> dict:
        """
        For deployment available public `/info` endpoint,  which provides build and git related information.
        Args:
            data_partition_id (str): identifier of the data partition to query. If None sets by auth session.
        Returns:
            response data (dict)
        Raises:
            OSDUValidation: if request values are wrong.
            OSDUAPIError: if response is 4XX or 5XX
        """
        headers = self.auth.get_headers()
        if data_partition_id:
            headers["data-partition-id"] = data_partition_id

        url = urljoin(self.base_url, self.service_path, "v2/info")
        response = requests.get(url, headers=headers)
        if not response.ok:
            raise FileAPIError(response.text, response.status_code)
        return response.json()

    def get_file_collections_storage_instructions(
        self, data_partition_id: str | None = None
    ) -> dict:
        """
        get storage/upload location file-collection datasets
        Args:
            data_partition_id (str): identifier of the data partition to query. If None sets by auth session.
        Returns:
            response data (dict)
        Raises:
            OSDUValidation: if request values are wrong.
            OSDUAPIError: if response is 4XX or 5XX
        """
        headers = self.auth.get_headers()
        if data_partition_id:
            headers["data-partition-id"] = data_partition_id

        url = urljoin(
            self.base_url, self.service_path, "v2/file-collections/storageInstructions"
        )
        response = requests.post(url, headers=headers)
        if not response.ok:
            raise FileAPIError(response.text, response.status_code)
        return response.json()

    def get_file_collections_retrieval_instructions(
        self, data_partition_id: str | None = None
    ) -> dict:
        """
        Generate retrieval instructions (Eg - Signed URLs) for datasets
        Args:
            data_partition_id (str): identifier of the data partition to query. If None sets by auth session.
        Returns:
            response data (dict)
        Raises:
            OSDUValidation: if request values are wrong.
            OSDUAPIError: if response is 4XX or 5XX
        """
        headers = self.auth.get_headers()
        if data_partition_id:
            headers["data-partition-id"] = data_partition_id

        url = urljoin(
            self.base_url,
            self.service_path,
            "v2/file-collections/retrievalInstructions",
        )
        response = requests.post(url, headers=headers)
        if not response.ok:
            raise FileAPIError(response.text, response.status_code)
        return response.json()

    def copy_file_collections(self, data_partition_id: str | None = None) -> dict:
        """
        Copy file collection from
        Args:
            data_partition_id (str): identifier of the data partition to query. If None sets by auth session.
        Returns:
            response data (dict)
        Raises:
            OSDUValidation: if request values are wrong.
            OSDUAPIError: if response is 4XX or 5XX
        """
        headers = self.auth.get_headers()
        if data_partition_id:
            headers["data-partition-id"] = data_partition_id

        url = urljoin(self.base_url, self.service_path, "v2/file-collections/copy")
        response = requests.post(url, headers=headers)
        if not response.ok:
            raise FileAPIError(response.text, response.status_code)
        return response.json()
