# generated by datamodel-codegen:
#   filename:  swagger.yaml
#   timestamp: 2024-07-14T16:59:16+00:00

from __future__ import annotations

from datetime import date, datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field, RootModel, confloat


class AboutResponse(BaseModel):
    buildNumber: Optional[str] = Field(None, title="Buildnumber")
    cloudEnvironment: Optional[str] = Field(None, title="Cloudenvironment")
    release: Optional[str] = Field(None, title="Release")
    service: Optional[str] = Field(None, title="Service")
    version: Optional[str] = Field(None, title="Version")


class BodyUploadLogData(BaseModel):
    file: bytes = Field(..., title="File")


class BulkStatisticsStatus(Enum):
    error = "error"
    started = "started"
    running = "running"
    complete = "complete"


class CatalogItem(BaseModel):
    family: Optional[str] = Field("", title="Family")
    rule: str = Field(..., title="Rule")
    unit: str = Field(..., title="Unit")


class CreateUpdateRecordsResponse(BaseModel):
    recordCount: Optional[int] = Field(None, title="Recordcount")
    recordIdVersions: Optional[List[str]] = Field(None, title="Recordidversions")
    recordIds: Optional[List[str]] = Field(None, title="Recordids")
    skippedRecordIds: Optional[List[str]] = Field(None, title="Skippedrecordids")


class CursorQueryResponse(BaseModel):
    cursor: Optional[str] = Field(None, title="Cursor")
    results: Optional[List[Dict[str, Any]]] = Field(None, title="Results")
    totalCount: Optional[int] = Field(None, title="Totalcount")


class CurveStatistics(BaseModel):
    field_10_: str = Field(..., alias="10%", title="10th percentiles")
    field_50_: str = Field(..., alias="50%", title="50th percentiles")
    field_90_: str = Field(..., alias="90%", title="50th percentiles")
    max: str = Field(..., title="Minimum value")
    mean: str = Field(..., title="Mean value")
    min: str = Field(..., title="Maximum value")
    nonAbsentValuesCount: str = Field(..., title="Number of valid values in the curve")
    std: str = Field(..., title="Standard deviation value")
    totalCount: str = Field(..., title="Number of values in the curve")


class DataType(Enum):
    string = "string"
    number = "number"
    integer = "integer"
    boolean = "boolean"


class DataType1(Enum):
    string = "string"
    number = "number"
    integer = "integer"
    boolean = "boolean"


class DataType2(Enum):
    string = "string"
    number = "number"
    integer = "integer"
    boolean = "boolean"
    date_time = "date-time"


class DataframeBasicDescribe(BaseModel):
    columnCount: int = Field(..., title="Columncount")
    columns: List[str] = Field(
        ...,
        description="list of column. May be truncated if too many columns, then contains the firsts and lasts once",
        title="Columns",
    )
    indexEnd: str = Field(..., title="Indexend")
    indexStart: str = Field(..., title="Indexstart")
    indexType: str = Field(..., title="Indextype")
    rowCount: int = Field(..., title="Rowcount")


class DirectionWell(Enum):
    huff_n_puff = "huff-n-puff"
    injector = "injector"
    producer = "producer"
    uncertain = "uncertain"
    unknown = "unknown"


class FluidWell(Enum):
    air = "air"
    condensate = "condensate"
    dry = "dry"
    gas = "gas"
    gas_water = "gas-water"
    non_HC_gas = "non HC gas"
    non_HC_gas____CO2 = "non HC gas -- CO2"
    oil = "oil"
    oil_gas = "oil-gas"
    oil_water = "oil-water"
    steam = "steam"
    water = "water"
    water____brine = "water -- brine"
    water____fresh_water = "water -- fresh water"
    unknown = "unknown"


class Format(Enum):
    date = "date"
    date_time = "date-time"
    time = "time"
    byte = "byte"
    binary = "binary"
    boolean = "boolean"
    email = "email"
    uuid = "uuid"
    uri = "uri"
    int8 = "int8"
    int16 = "int16"
    int32 = "int32"
    int64 = "int64"
    float32 = "float32"
    float64 = "float64"
    float128 = "float128"


class Format1(Enum):
    date = "date"
    date_time = "date-time"
    time = "time"
    byte = "byte"
    binary = "binary"
    boolean = "boolean"
    email = "email"
    uuid = "uuid"
    uri = "uri"
    int8 = "int8"
    int16 = "int16"
    int32 = "int32"
    int64 = "int64"
    float32 = "float32"
    float64 = "float64"
    float128 = "float128"


class Format2(Enum):
    date = "date"
    date_time = "date-time"
    time = "time"
    byte = "byte"
    binary = "binary"
    email = "email"
    uuid = "uuid"
    uri = "uri"
    int8 = "int8"
    int16 = "int16"
    int32 = "int32"
    int64 = "int64"
    float32 = "float32"
    float64 = "float64"
    float128 = "float128"


class GetLogDataResponse1(BaseModel):
    columns: Optional[List[Union[str, int, float]]] = Field(None, title="Columns")
    data: Union[List[Union[str, int, float]], List[List[Union[str, int, float]]]] = (
        Field(..., title="Data")
    )
    index: Optional[List[Union[str, int, float]]] = Field(None, title="Index")


class GetLogDataResponse(RootModel):
    root: Union[GetLogDataResponse1, Dict[str, Dict[str, Union[str, int, float]]]]


class GetTrajectoryDataResponse1(BaseModel):
    columns: Optional[List[Union[str, int, float]]] = Field(None, title="Columns")
    data: Union[List[Union[str, int, float]], List[List[Union[str, int, float]]]] = (
        Field(..., title="Data")
    )
    index: Optional[List[Union[str, int, float]]] = Field(None, title="Index")


class GetTrajectoryDataResponse(RootModel):
    root: Union[
        GetTrajectoryDataResponse1, Dict[str, Dict[str, Union[str, int, float]]]
    ]


class GuessRequest(BaseModel):
    description: Optional[str] = Field(None, title="Description")
    label: str = Field(..., title="Label")
    log_unit: Optional[str] = Field(None, title="Log Unit")


class GuessResponse(BaseModel):
    base_unit: Optional[str] = Field(None, title="Base Unit")
    family: Optional[str] = Field(None, title="Family")
    family_type: Optional[List[str]] = Field(None, title="Family Type")
    log_unit: Optional[str] = Field(None, title="Log Unit")


class JSONOrient(Enum):
    split = "split"
    columns = "columns"


class Kind(Enum):
    CRS = "CRS"
    Unit = "Unit"
    Measurement = "Measurement"
    AzimuthReference = "AzimuthReference"
    DateTime = "DateTime"


class LinkList(BaseModel):
    pass


class MainFamilyCatalogItem(BaseModel):
    Family: str = Field(..., title="Family")
    MainFamily: str = Field(..., title="Mainfamily")
    Unit: str = Field(..., title="Unit")


class MetaItem(BaseModel):
    kind: Kind = Field(
        ...,
        description="The kind of reference, unit, measurement, CRS or azimuth reference.",
        title="Reference Kind",
    )
    name: Optional[str] = Field(
        None,
        description="The name of the CRS or the symbol/name of the unit",
        title="Name or Symbol",
    )
    persistableReference: str = Field(
        ...,
        description="The persistable reference string uniquely identifying the CRS or Unit",
        title="Persistable Reference",
    )
    propertyNames: Optional[List[str]] = Field(
        None,
        description='The list of property names, to which this meta data item provides Unit/CRS context to. Data structures, which come in a single frame of reference, can register the property name, others require a full path like "data.structureA.propertyB" to define a unique context.',
        title="Attribute Names",
    )
    propertyValues: Optional[List[str]] = Field(
        None,
        description="The list of property values, to which this meta data item provides Unit/CRS context to. Typically a unit symbol is a value to a data structure; this symbol is then registered in this propertyValues array and the persistableReference provides the absolute reference.",
        title="Attribute Names",
    )
    uncertainty: Optional[float] = Field(
        None,
        description="The uncertainty of the values measured given the unit or CRS unit.",
        title="Uncertainty",
    )


class PlssLocation(BaseModel):
    model_config = ConfigDict(extra="forbid")

    aliquotPart: Optional[str] = Field(
        None,
        description="A terse, hierarchical reference to a piece of land, in which successive subdivisions of some larger area.",
        title="Aliquot Part",
    )
    range: str = Field(
        ...,
        description="Range, also known as Rng, R; a measure of the distance east or west from a referenced principal meridian, in units of six miles.",
        title="Range",
    )
    section: int = Field(
        ..., description="Section number (between 1 and 36)", title="Section Number"
    )
    township: str = Field(
        ...,
        description="Township, also known as T or Twp; (1) Synonym for survey township, i.e., a square parcel of land of 36 square miles, or (2) A measure of the distance north or south from a referenced baseline, in units of six miles",
        title="Township",
    )


class Point3dNonGeoJson(BaseModel):
    model_config = ConfigDict(extra="forbid")

    coordinates: List[float] = Field(
        ...,
        description="3-dimensional point; the first coordinate is typically pointing east (easting or longitude), the second coordinate typically points north (northing or latitude). The third coordinate is an elevation (upwards positive, downwards negative). The point's CRS is given by the container.",
        title="3D Point",
    )
    crsKey: str = Field(
        ...,
        description="The 'crsKey', which can be looked up in the 'frameOfReference.crs' for further details.",
        title="CRS Key",
    )
    unitKey: str = Field(
        ...,
        description="The 'unitKey' for the 3rd coordinate, which can be looked up in the 'frameOfReference.unit' for further details.",
        title="Unit Key",
    )


class RecordAncestry(BaseModel):
    parents: Optional[List[str]] = Field(None, title="Parents")


class RecordVersions(BaseModel):
    recordId: Optional[str] = Field(None, title="Recordid")
    versions: Optional[List[int]] = Field(None, title="Versions")


class ReferenceType(Enum):
    Date = "Date"
    Date_Time = "Date Time"
    Measured_Depth = "Measured Depth"
    Core_depth = "Core depth"
    True_Vertical_Depth = "True Vertical Depth"
    True_Vertical_Depth_Sub_Sea = "True Vertical Depth Sub Sea"
    One_Way_Time = "One-Way Time"
    Two_Way_Time = "Two-Way Time"


class SearchQuery(BaseModel):
    query: Optional[str] = Field(None, title="Query")


class SearchQueryRequest(BaseModel):
    cursor: Optional[str] = Field(None, title="Cursor")
    limit: Optional[int] = Field(None, title="Limit")
    offset: Optional[int] = Field(None, title="Offset")
    query: Optional[str] = Field(None, title="Query")


class SessionState(Enum):
    open = "open"
    committing = "committing"
    abandoning = "abandoning"
    committed = "committed"
    abandoned = "abandoned"


class SessionUpdateMode(Enum):
    overwrite = "overwrite"
    update = "update"


class Shape(Enum):
    build_and_hold = "build and hold"
    deviated = "deviated"
    double_kickoff = "double kickoff"
    horizontal = "horizontal"
    S_shaped = "S-shaped"
    vertical = "vertical"
    unknown = "unknown"


class StatsColumn(BaseModel):
    field_25_: float = Field(..., alias="25%", title="25%")
    field_50_: float = Field(..., alias="50%", title="50%")
    field_75_: float = Field(..., alias="75%", title="75%")
    count: int = Field(
        ..., description="Count number of non-NA/null observations", title="Count"
    )
    max: float = Field(
        ..., description="Maximum of the values in the object", title="Max"
    )
    mean: float = Field(..., description="Mean of the values", title="Mean")
    min: float = Field(
        ..., description="Minimum of the values in the object", title="Min"
    )
    std: float = Field(
        ..., description="Standard deviation of the observations", title="Std"
    )


class StorageAcl(BaseModel):
    owners: List[str] = Field(..., title="Owners")
    viewers: List[str] = Field(..., title="Viewers")


class TagDictionary(BaseModel):
    pass


class Tags(RootModel):
    root: str = Field(..., title="Tags")


class ToOneRelationship(BaseModel):
    model_config = ConfigDict(extra="forbid")

    confidence: Optional[float] = Field(
        None,
        description="The confidence of the relationship. If the property is absent a well-known relation is implied.",
        title="Relationship Confidence",
    )
    id: Optional[str] = Field(
        None,
        description="The id of the related object in the Data Ecosystem. If set, the id has priority over the natural key in the name property.",
        title="Related Object Id",
    )
    name: Optional[str] = Field(
        None,
        description="The name or natural key of the related object. This property is required if the target object id could not (yet) be identified.",
        title="Related Object Name",
    )
    version: Optional[float] = Field(
        None,
        description="The version number of the related entity. If no version number is specified, the last version is implied.",
        title="Entity Version Number",
    )


class Type(Enum):
    GeometryCollection = "GeometryCollection"


class Type1(Enum):
    Feature = "Feature"


class Type2(Enum):
    FeatureCollection = "FeatureCollection"


class Type3(Enum):
    LineString = "LineString"


class Type4(Enum):
    MultiLineString = "MultiLineString"


class Type5(Enum):
    MultiPoint = "MultiPoint"


class Type6(Enum):
    MultiPolygon = "MultiPolygon"


class Type7(Enum):
    Point = "Point"


class Type8(Enum):
    Polygon = "Polygon"


class UpdateSessionStateValue(Enum):
    commit = "commit"
    abandon = "abandon"


class ValidationError(BaseModel):
    loc: List[Union[str, int]] = Field(..., title="Location")
    msg: str = Field(..., title="Message")
    type: str = Field(..., title="Error Type")


class ValueWithUnit(BaseModel):
    model_config = ConfigDict(extra="forbid")

    unitKey: str = Field(
        ...,
        description="Unit for value of the corresponding attribute for the domain object in question. The key can be looked up in the 'frameOfReference.units' for further details.",
        title="Unit Key",
    )
    value: float = Field(
        ...,
        description="Value of the corresponding attribute for the domain object in question.",
        title="Value",
    )


class VersionDetailsResponse(BaseModel):
    buildNumber: Optional[str] = Field(None, title="Buildnumber")
    details: Optional[Dict[str, str]] = Field(None, title="Details")
    release: Optional[str] = Field(None, title="Release")
    service: Optional[str] = Field(None, title="Service")
    version: Optional[str] = Field(None, title="Version")


class WellLocationType(Enum):
    Onshore = "Onshore"
    Offshore = "Offshore"
    unknown = "unknown"


class WellPurpose(Enum):
    appraisal = "appraisal"
    appraisal____confirmation_appraisal = "appraisal -- confirmation appraisal"
    appraisal____exploratory_appraisal = "appraisal -- exploratory appraisal"
    exploration = "exploration"
    exploration____deeper_pool_wildcat = "exploration -- deeper-pool wildcat"
    exploration____new_field_wildcat = "exploration -- new-field wildcat"
    exploration____new_pool_wildcat = "exploration -- new-pool wildcat"
    exploration____outpost_wildcat = "exploration -- outpost wildcat"
    exploration____shallower_pool_wildcat = "exploration -- shallower-pool wildcat"
    development = "development"
    development____infill_development = "development -- infill development"
    development____injector = "development -- injector"
    development____producer = "development -- producer"
    fluid_storage = "fluid storage"
    fluid_storage____gas_storage = "fluid storage -- gas storage"
    general_srvc = "general srvc"
    general_srvc____borehole_re_acquisition = "general srvc -- borehole re-acquisition"
    general_srvc____observation = "general srvc -- observation"
    general_srvc____relief = "general srvc -- relief"
    general_srvc____research = "general srvc -- research"
    general_srvc____research____drill_test = "general srvc -- research -- drill test"
    general_srvc____research____strat_test = "general srvc -- research -- strat test"
    general_srvc____waste_disposal = "general srvc -- waste disposal"
    mineral = "mineral"
    unknown = "unknown"


class WellStatus(Enum):
    abandoned = "abandoned"
    active = "active"
    active____injecting = "active -- injecting"
    active____producing = "active -- producing"
    completed = "completed"
    drilling = "drilling"
    partially_plugged = "partially plugged"
    permitted = "permitted"
    plugged_and_abandoned = "plugged and abandoned"
    proposed = "proposed"
    sold = "sold"
    suspended = "suspended"
    temporarily_abandoned = "temporarily abandoned"
    testing = "testing"
    tight = "tight"
    working_over = "working over"
    unknown = "unknown"


class WellType(Enum):
    bypass = "bypass"
    initial = "initial"
    redrill = "redrill"
    reentry = "reentry"
    respud = "respud"
    sidetrack = "sidetrack"
    unknown = "unknown"


class WellborePurpose(Enum):
    appraisal = "appraisal"
    appraisal____confirmation_appraisal = "appraisal -- confirmation appraisal"
    appraisal____exploratory_appraisal = "appraisal -- exploratory appraisal"
    exploration = "exploration"
    exploration____deeper_pool_wildcat = "exploration -- deeper-pool wildcat"
    exploration____new_field_wildcat = "exploration -- new-field wildcat"
    exploration____new_pool_wildcat = "exploration -- new-pool wildcat"
    exploration____outpost_wildcat = "exploration -- outpost wildcat"
    exploration____shallower_pool_wildcat = "exploration -- shallower-pool wildcat"
    development = "development"
    development____infill_development = "development -- infill development"
    development____injector = "development -- injector"
    development____producer = "development -- producer"
    fluid_storage = "fluid storage"
    fluid_storage____gas_storage = "fluid storage -- gas storage"
    general_srvc = "general srvc"
    general_srvc____borehole_re_acquisition = "general srvc -- borehole re-acquisition"
    general_srvc____observation = "general srvc -- observation"
    general_srvc____relief = "general srvc -- relief"
    general_srvc____research = "general srvc -- research"
    general_srvc____research____drill_test = "general srvc -- research -- drill test"
    general_srvc____research____strat_test = "general srvc -- research -- strat test"
    general_srvc____waste_disposal = "general srvc -- waste disposal"
    mineral = "mineral"
    unknown = "unknown"


class WellboreStatus(Enum):
    abandoned = "abandoned"
    active = "active"
    active____injecting = "active -- injecting"
    active____producing = "active -- producing"
    completed = "completed"
    drilling = "drilling"
    partially_plugged = "partially plugged"
    permitted = "permitted"
    plugged_and_abandoned = "plugged and abandoned"
    proposed = "proposed"
    sold = "sold"
    suspended = "suspended"
    temporarily_abandoned = "temporarily abandoned"
    testing = "testing"
    tight = "tight"
    working_over = "working over"
    unknown = "unknown"


class WellboreType(Enum):
    bypass = "bypass"
    initial = "initial"
    redrill = "redrill"
    reentry = "reentry"
    respud = "respud"
    sidetrack = "sidetrack"
    unknown = "unknown"


class AppModelModelCuratedLegal(BaseModel):
    model_config = ConfigDict(extra="forbid")

    legaltags: Optional[List[str]] = Field(
        None,
        description="The list of legal tags, see compliance API.",
        title="Legal Tags",
    )
    otherRelevantDataCountries: Optional[List[str]] = Field(
        None,
        description="The list of other relevant data countries using the ISO 2-letter codes, see compliance API.",
        title="Other Relevant Data Countries",
    )
    status: Optional[str] = Field(
        None, description="The legal status.", title="Legal Status"
    )


class BasinContext(BaseModel):
    model_config = ConfigDict(extra="forbid")

    basinCode: Optional[str] = Field(
        None,
        description="The code of the basin in which the well is located.",
        title="Basin Code",
    )
    basinName: Optional[str] = Field(
        None,
        description="The name of the basin in which the well is located.",
        title="Basin Name",
    )
    subBasinCode: Optional[str] = Field(
        None,
        description="The code of the sub-basin in which the well is located.",
        title="Sub-Basin Code",
    )
    subBasinName: Optional[str] = Field(
        None,
        description="The name of the sub-basin in which the well is located.",
        title="Sub-Basin Name",
    )


class CoreDlGeopoint(BaseModel):
    model_config = ConfigDict(extra="forbid")

    latitude: confloat(ge=-90.0, le=90.0) = Field(
        ...,
        description="The latitude value in degrees of arc (dega). Value range [-90, 90].",
        title="Latitude",
    )
    longitude: confloat(ge=-180.0, le=180.0) = Field(
        ...,
        description="The longitude value in degrees of arc (dega). Value range [-180, 180]",
        title="Longitude",
    )


class Dipsetrelationships(BaseModel):
    classificationLog: Optional[ToOneRelationship] = Field(
        None,
        description="The classification log of the dipset",
        title="Classification log",
    )
    qualityLog: Optional[ToOneRelationship] = Field(
        None, description="The quality log of the dipset", title="Quality log"
    )
    referenceLog: Optional[ToOneRelationship] = Field(
        None,
        description="The true dip azimuth log of the dipset.",
        title="True dip azimuth log",
    )
    trueDipAzimuthLog: Optional[ToOneRelationship] = Field(
        None,
        description="The true dip azimuth log of the dipset.",
        title="True dip azimuth log",
    )
    trueDipInclinationLog: Optional[ToOneRelationship] = Field(
        None, description="The X-coordinate log of the dipset", title="X-coordinate log"
    )
    well: Optional[ToOneRelationship] = Field(
        None,
        description="The well to which this dipSet belongs. Only required if the wellbore is unknown.",
        title="Well",
    )
    wellbore: ToOneRelationship = Field(
        ..., description="The wellbore to which this dipSet belongs.", title="Wellbore"
    )
    wellboreSection: Optional[ToOneRelationship] = Field(
        None,
        description="The wellbore section to which this dipSet belongs.",
        title="Wellbore Section",
    )
    xCoordinateLog: Optional[ToOneRelationship] = Field(
        None, description="The X-coordinate log of the dipset", title="X-coordinate log"
    )
    yCoordinateLog: Optional[ToOneRelationship] = Field(
        None, description="The Y-coordinate log of the dipset", title="Y-coordinate log"
    )
    zCoordinateLog: Optional[ToOneRelationship] = Field(
        None, description="The Z-coordinate log of the dipset", title="Z-coordinate log"
    )


class GeographicPosition(BaseModel):
    model_config = ConfigDict(extra="forbid")

    crsKey: str = Field(
        ...,
        description="The 'crsKey', which can be looked up in the 'frameOfReference.crs' for further details.",
        title="CRS Key",
    )
    elevationFromMsl: ValueWithUnit = Field(
        ...,
        description="Elevation from Mean Seal Level, downwards negative. The unit definition is found via 'elevationFromMsl.unitKey' in 'frameOfReference.units' dictionary.",
        title="Elevation from MSL",
    )
    latitude: float = Field(
        ...,
        description="Native or original latitude (unit defined by CRS)",
        title="Native Latitude",
    )
    longitude: float = Field(
        ...,
        description="Native or original longitude (unit defined by CRS)",
        title="Native Longitude",
    )


class HistoryRecord(BaseModel):
    model_config = ConfigDict(extra="forbid")

    date: Optional[datetime] = Field(
        None,
        description="The UTC date time of the log creation/processing",
        title="Date and Time",
    )
    description: Optional[str] = Field(
        None,
        description="The description of the context, which produced the log.",
        title=" Description",
    )
    user: Optional[str] = Field(
        None, description="The user running the log processing.", title="User"
    )


class LogRelationships(BaseModel):
    logSet: Optional[ToOneRelationship] = Field(
        None,
        description="The logSet to which this log belongs. If the log is not part of a log set this relationship stays empty.",
        title="LogSet",
    )
    timeDepthRelation: Optional[ToOneRelationship] = Field(
        None,
        description="The timeDepthRelation to which this log belongs. If the log is not part of a timeDepthRelation this relationship stays empty.",
        title="TimeDepthRelation LogSet",
    )
    well: Optional[ToOneRelationship] = Field(
        None,
        description="The well to which this log belongs. Only required if the wellbore is unknown.",
        title="Well",
    )
    wellbore: Optional[ToOneRelationship] = Field(
        None,
        description="The wellbore to which this log belongs. This relationship is the most important; only the wellbore can provide the unique context for the measured depth index.",
        title="Wellbore",
    )


class Logsetrelationships(BaseModel):
    well: Optional[ToOneRelationship] = Field(
        None,
        description="The well to which this logSet belongs. Only required if the wellbore is unknown.",
        title="Well",
    )
    wellbore: ToOneRelationship = Field(
        ..., description="The wellbore to which this logSet belongs.", title="Wellbore"
    )
    wellboreSection: Optional[ToOneRelationship] = Field(
        None,
        description="The wellboreSection to which this logSet belongs.",
        title="Wellbore Section",
    )


class Markerrelationships(BaseModel):
    horizon: Optional[ToOneRelationship] = Field(
        None,
        description="The related stratigraphic horizon",
        title="Stratigraphic Horizon",
    )
    stratigraphicTable: Optional[ToOneRelationship] = Field(
        None,
        description="The related stratigraphic table, which provides the context for the stratigraphic horizon",
        title="Stratigraphic Table",
    )
    study: Optional[ToOneRelationship] = Field(
        None,
        description="The study, in which this marker was conceived.",
        title="Study",
    )
    trajectory: Optional[ToOneRelationship] = Field(
        None,
        description="The trajectory used to create the marker position",
        title="Trajectory",
    )
    wellbore: Optional[ToOneRelationship] = Field(
        None,
        description="The wellbore entity, to which this marker belongs.",
        title="Wellbore",
    )


class NamedProperty(BaseModel):
    model_config = ConfigDict(extra="forbid")

    associations: Optional[List[str]] = Field(
        None,
        description="The optional associations contains one or more mnemonics found elsewhere in the logSet.",
        title="Associations",
    )
    description: Optional[str] = Field(
        None,
        description="The description and role of this property.",
        title="Property Description",
    )
    format: Optional[str] = Field(
        None,
        description="An optional format declaration for the property values. The 'A' prefix indicates an array; string values are represented by 'S'; floating point values are represented by 'F', optionally followed by a field specification, e.g. 'F10.4'; exponential number representations are represented by 'E'; integer values are represented by 'I'. For further information see the LAS specification http://www.cwls.org/las/.",
        title="Format (LAS)",
    )
    name: Optional[str] = Field(
        None, description="The name of this property.", title="Property Name"
    )
    unitKey: Optional[str] = Field(
        None,
        description="The unitKey to be looked up in the 'frameOfReference.units' dictionary to find the self-contained definition.",
        title="Property Unit Symbol",
    )
    value: Optional[Union[float, int, str]] = Field(
        None,
        description="The value for this property as a string or a number.",
        title="Property Value",
    )
    values: Optional[List[float]] = Field(
        None,
        description="The values, e.g. interval boundaries, for this property.",
        title="Property Values (Interval)",
    )


class OdesStorageModelsLegal(BaseModel):
    legaltags: Optional[List[str]] = Field(None, title="Legaltags")
    otherRelevantDataCountries: Optional[List[str]] = Field(
        None, title="Otherrelevantdatacountries"
    )


class ProjectedPosition(BaseModel):
    model_config = ConfigDict(extra="forbid")

    crsKey: str = Field(
        ...,
        description="The 'crsKey', which can be looked up in the 'frameOfReference.crs' for further details.",
        title="CRS Key",
    )
    elevationFromMsl: ValueWithUnit = Field(
        ...,
        description="Elevation from Mean Seal Level, downwards negative. The unit definition is found via 'elevationFromMsl.unitKey' in 'frameOfReference.units' dictionary.",
        title="Elevation from MSL",
    )
    x: float = Field(
        ...,
        description="X-coordinate value in native or original projected CRS",
        title="X Coordinate",
    )
    y: float = Field(
        ...,
        description="Y-coordinate value in native or original projected CRS",
        title="Y Coordinate",
    )


class Trajectorychannel(BaseModel):
    model_config = ConfigDict(extra="forbid")

    absentValue: Optional[str] = Field(
        None,
        description="Optional field carrying the absent value as string for this channel.",
        title="Absent Value",
    )
    azimuthKey: Optional[str] = Field(
        None,
        description="The azimuth reference of this log or channel. The detailed definition is found as persistable reference in the 'frameOfReference.azimuth' dictionary.",
        title="Azimuth Reference Key",
    )
    bulkURI: Optional[str] = Field(
        None, description="bulkURI either URL or URN.", title="bulk URI"
    )
    crsKey: Optional[str] = Field(
        None,
        description="The CRS key of this log or channel. The detailed definition is found as persistable reference in the 'frameOfReference.crs' dictionary.",
        title="CRS Key",
    )
    dataType: Optional[DataType1] = Field(
        "number",
        description="The log value type (per log sample). The 'format' property may contain further hints about data type presentation.",
        title="Data Type",
    )
    dimension: Optional[int] = Field(
        None, description="The dimension of this log or channel", title="Dimension"
    )
    family: Optional[str] = Field(
        None,
        description="The log family code of this log or channel (optional)",
        title="Log Family",
    )
    familyType: Optional[str] = Field(
        None,
        description="The log family type code of this log or channel. Example: 'Neutron Porosity' for 'Thermal Neutron Porosity Sandstone'. (optional)",
        title="Log Family Type",
    )
    format: Optional[Format1] = Field(
        "float32",
        description="Optional format hint how to treat the log values as strings or number of bits per 'dataType'.",
        title="Format Hint",
    )
    logstoreId: Optional[float] = Field(
        None,
        description="The id of this log or channel in the Logstore. This property is not present in the index channel.",
        title="Logstore ID",
    )
    longName: Optional[str] = Field(
        None, description="The long name of this log or channel", title="Log Long Name"
    )
    mnemonic: Optional[str] = Field(
        None, description="The mnemonic of this log or channel", title="Mnemonic"
    )
    name: Optional[str] = Field(
        None, description="The name of this log or channel.", title="Log Name"
    )
    properties: Optional[List[str]] = Field(
        None, description="The properties of this log or channel.", title="Properties"
    )
    source: Optional[str] = Field(
        None,
        description="The source of this log or channel as a data reference; Typically this refers to the raw trajectory, from which this log WKE is generated.",
        title="Source",
    )
    unitKey: Optional[str] = Field(
        None,
        description="The unit key of this log or channel. The detailed definition is found as persistable reference in the 'frameOfReference.units' dictionary. Empty units (NoUnit) are not recorded.",
        title="Unit Key",
    )


class Trajectoryrelationships(BaseModel):
    wellbore: ToOneRelationship = Field(
        ...,
        description="The wellbore to which this trajectory belongs.",
        title="Wellbore",
    )


class Wellborerelationships(BaseModel):
    definitiveTimeDepthRelation: Optional[ToOneRelationship] = Field(
        None,
        description="The definitive tome-depth relation providing the MD to seismic travel-time transformation.",
        title="Definitive Time-Depth Relation",
    )
    definitiveTrajectory: Optional[ToOneRelationship] = Field(
        None,
        description="The definitive trajectory providing the MD to 3D space transformation.",
        title="Definitive Trajectory",
    )
    tieInWellbore: Optional[ToOneRelationship] = Field(
        None,
        description="The tie-in wellbore if this wellbore is a side-track.",
        title="Tie-in Wellbore",
    )
    well: Optional[ToOneRelationship] = Field(
        None, description="The well to which this wellbore belongs.", title="Well"
    )


class Wellrelationships(BaseModel):
    asset: Optional[ToOneRelationship] = Field(
        None, description="The asset this well belongs to.", title="Asset"
    )


class Wgs84Position(BaseModel):
    model_config = ConfigDict(extra="forbid")

    elevationFromMsl: ValueWithUnit = Field(
        ...,
        description="Elevation from Mean Seal Level, downwards negative. The unit definition is found via 'elevationFromMsl.unitKey' in 'frameOfReference.units' dictionary.",
        title="Elevation from MSL",
    )
    latitude: float = Field(
        ...,
        description="WGS 84 latitude value in degrees (dega)",
        title="WGS 84 Latitude",
    )
    longitude: float = Field(
        ...,
        description="WGS 84 longitude value in degrees (dega)",
        title="WGS 84 Longitude",
    )


class BulkDataStatisticsResponse(BaseModel):
    computationStartDatetime: datetime = Field(
        ..., title="Statistics computation start datetime in ISO format"
    )
    computationStatus: BulkStatisticsStatus
    data: Dict[str, CurveStatistics] = Field(
        ...,
        title="Curves statistics' values",
        json_schema_extra=dict(
            example={
                "CurveName": {
                    "10%": "9.0",
                    "50%": "451.0",
                    "90%": "893.0",
                    "max": "999.0",
                    "mean": "450.8438",
                    "min": "-100.0",
                    "nonAbsentValuesCount": "100000.0",
                    "std": "318.27778186518816",
                    "totalCount": "100000",
                }
            }
        ),
    )
    recordId: str = Field(..., title="Recordid")
    recordVersion: int = Field(..., title="Recordversion")


class Catalog(BaseModel):
    family_catalog: List[CatalogItem] = Field(..., title="Family Catalog")
    main_family_catalog: Optional[List[MainFamilyCatalogItem]] = Field(
        None, title="Main Family Catalog"
    )


class CatalogRecord(BaseModel):
    acl: StorageAcl
    data: Catalog
    legal: OdesStorageModelsLegal


class CommitSessionResponse(BaseModel):
    createdTime: datetime = Field(..., description="creation date", title="Createdtime")
    expiry: datetime = Field(
        ...,
        description="If the session is not committed before this dead line, session is automatically abandoned.",
        title="Expiry",
    )
    fromVersion: int = Field(
        ...,
        description="record version on top of which the session is based.",
        title="Fromversion",
    )
    id: UUID = Field(..., description="identifier of the current session.", title="Id")
    meta: Optional[Dict[str, str]] = Field(
        None,
        description="miscellaneous metadata associated to the session. The session creator can set some data here.",
        title="Meta",
    )
    mode: SessionUpdateMode = Field(
        ...,
        description="merge mode at commit. If 'update', existing data will be merged with the data sent during the session. If 'overrride', existing data will be ignored, the final result will only contains data sent within the session.",
    )
    recordId: str = Field(
        ...,
        description="identifier of the record of which the session is attached to.",
        title="Recordid",
    )
    state: SessionState
    updatedTime: datetime = Field(..., description="updated date", title="Updatedtime")
    version: Optional[int] = Field(
        None,
        description="Record version in case of successful commit",
        title="Version Number",
        json_schema_extra=dict(
            example=1562066009929332,
        ),
    )


class CreateDataSessionRequest(BaseModel):
    fromVersion: Optional[int] = Field(
        0,
        description="specify the version on top of which update will be applied. By default use the latest one (0). Not relevant if overwrite is set to True.",
        title="Fromversion",
    )
    meta: Optional[Dict[str, str]] = Field(
        None, description="dictionary all values, stored in the session", title="Meta"
    )
    mode: SessionUpdateMode = Field(
        ...,
        description="merge mode at commit. If 'update', existing data will be merged with the data sent during the session. If 'overwrite', existing data will be ignored, the final result will only contains data sent within the session.",
    )
    timeToLive: Optional[int] = Field(
        1440, description="optional - time to live in minutes.", title="Timetolive"
    )


class Dip(BaseModel):
    azimuth: ValueWithUnit = Field(
        ...,
        description="Only degrees unit is supported for the moment",
        title="Azimuth value of the dip",
    )
    classification: Optional[str] = Field(
        None, description="Any string is accepted.", title="Classification of the dip"
    )
    inclination: ValueWithUnit = Field(
        ...,
        description="Only degrees unit is supported for the moment",
        title="Inclination value of the dip",
    )
    quality: Optional[ValueWithUnit] = Field(
        None, description="Decimal number between 0 and 1", title="Quality of the dip"
    )
    reference: ValueWithUnit = Field(
        ...,
        description="Only Measured Depth in meter is supported for the moment",
        title="Reference of the dip",
    )
    xCoordinate: Optional[ValueWithUnit] = Field(
        None,
        description="Only meter unit is supported for the moment",
        title="The X coordinate of the dip",
    )
    yCoordinate: Optional[ValueWithUnit] = Field(
        None,
        description="Only meter unit is supported for the moment",
        title="The Y coordinate of the dip",
    )
    zCoordinate: Optional[ValueWithUnit] = Field(
        None,
        description="Only meter unit is supported for the moment",
        title="The Z coordinate of the dip",
    )


class GeoJsonLineString(BaseModel):
    model_config = ConfigDict(extra="forbid")

    bbox: Optional[List[float]] = Field(None, title="Bbox")
    coordinates: List[List[float]] = Field(..., title="Coordinates")
    type: Type3


class GeoJsonMultiLineString(BaseModel):
    model_config = ConfigDict(extra="forbid")

    bbox: Optional[List[float]] = Field(None, title="Bbox")
    coordinates: List[List[List[float]]] = Field(..., title="Coordinates")
    type: Type4


class GeoJsonMultiPoint(BaseModel):
    model_config = ConfigDict(extra="forbid")

    bbox: Optional[List[float]] = Field(None, title="Bbox")
    coordinates: List[List[float]] = Field(..., title="Coordinates")
    type: Type5


class GeoJsonMultiPolygon(BaseModel):
    model_config = ConfigDict(extra="forbid")

    bbox: Optional[List[float]] = Field(
        None, description="Bounding box in longitude, latitude WGS 84.", title="Bbox"
    )
    coordinates: List[List[List[List[float]]]] = Field(
        ...,
        description="Array of polygons (minimum 2D), containing an array of point coordinates (longitude, latitude, (optionally elevation and other properties).",
        title="Coordinates",
    )
    type: Type6


class GeoJsonPoint(BaseModel):
    model_config = ConfigDict(extra="forbid")

    bbox: Optional[List[float]] = Field(None, title="Bbox")
    coordinates: List[float] = Field(..., title="Coordinates")
    type: Type7


class HTTPValidationError(BaseModel):
    errors: Optional[List[ValidationError]] = Field(None, title="Errors")


class Polygon(BaseModel):
    model_config = ConfigDict(extra="forbid")

    bbox: Optional[List[float]] = Field(None, title="Bbox")
    coordinates: List[List[List[float]]] = Field(..., title="Coordinates")
    type: Type8


class Record(BaseModel):
    acl: StorageAcl
    ancestry: Optional[RecordAncestry] = None
    createTime: Optional[datetime] = Field(None, title="Createtime")
    createUser: Optional[str] = Field(None, title="Createuser")
    data: Dict[str, Any] = Field(..., title="Data")
    id: Optional[str] = Field(None, title="Id")
    kind: str = Field(..., title="Kind")
    legal: OdesStorageModelsLegal
    meta: Optional[List[Dict[str, Any]]] = Field(None, title="Meta")
    modifyTime: Optional[datetime] = Field(None, title="Modifytime")
    modifyUser: Optional[str] = Field(None, title="Modifyuser")
    tags: Optional[Dict[str, str]] = Field(None, title="Tags")
    version: Optional[int] = Field(None, title="Version")


class Session(BaseModel):
    createdTime: datetime = Field(..., description="creation date", title="Createdtime")
    expiry: datetime = Field(
        ...,
        description="If the session is not committed before this dead line, session is automatically abandoned.",
        title="Expiry",
    )
    fromVersion: int = Field(
        ...,
        description="record version on top of which the session is based.",
        title="Fromversion",
    )
    id: UUID = Field(..., description="identifier of the current session.", title="Id")
    meta: Optional[Dict[str, str]] = Field(
        None,
        description="miscellaneous metadata associated to the session. The session creator can set some data here.",
        title="Meta",
    )
    mode: SessionUpdateMode = Field(
        ...,
        description="merge mode at commit. If 'update', existing data will be merged with the data sent during the session. If 'overrride', existing data will be ignored, the final result will only contains data sent within the session.",
    )
    recordId: str = Field(
        ...,
        description="identifier of the record of which the session is attached to.",
        title="Recordid",
    )
    state: SessionState
    updatedTime: datetime = Field(..., description="updated date", title="Updatedtime")


class SimpleElevationReference(BaseModel):
    model_config = ConfigDict(extra="forbid")

    elevationFromMsl: ValueWithUnit = Field(
        ...,
        description="The elevation above mean sea level (MSL), at which the vertical origin is 0.0. The 'unitKey' is further defined in 'frameOfReference.units'.",
        title="Elevation from MSL",
    )
    name: Optional[str] = Field(
        None,
        description="The name of the Elevation Reference.",
        title="Elevation Reference Name",
    )


class UpdateSessionState(BaseModel):
    state: UpdateSessionStateValue = Field(
        ..., description="`commit` or `abandon` a session"
    )


class Channel(BaseModel):
    model_config = ConfigDict(extra="forbid")

    absentValue: Optional[str] = Field(
        None,
        description="Optional field carrying the absent value as string for this channel.",
        title="Absent Value",
    )
    bulkURI: Optional[str] = Field(
        None, description="bulkURI either URL or URN.", title="bulk URI"
    )
    dataType: Optional[DataType] = Field(
        "number",
        description="The log value type (per log sample). The 'format' property may contain further hints about data type presentation.",
        title="Data Type",
    )
    dimension: Optional[int] = Field(
        None, description="The dimension of this log or channel", title="Dimension"
    )
    family: Optional[str] = Field(
        None,
        description="The log family code of this log or channel (optional)",
        title="Log Family",
    )
    familyType: Optional[str] = Field(
        None,
        description="The log family type code of this log or channel. Example: 'Neutron Porosity' for 'Thermal Neutron Porosity Sandstone'. (optional)",
        title="Log Family Type",
    )
    format: Optional[Format] = Field(
        "float32",
        description="Optional format hint how to treat the log values as strings or number of bits per 'dataType'.",
        title="Format Hint",
    )
    logstoreId: Optional[float] = Field(
        None,
        description="The id of this log or channel in the Logstore. This property is not present in the index channel.",
        title="Logstore ID",
    )
    longName: Optional[str] = Field(
        None, description="The long name of this log or channel", title="Log Long Name"
    )
    mnemonic: Optional[str] = Field(
        None, description="The mnemonic of this log or channel", title="Mnemonic"
    )
    name: Optional[str] = Field(
        None, description="The name of this log or channel.", title="Log Name"
    )
    properties: Optional[List[NamedProperty]] = Field(
        None,
        description="The named properties of this log or channel.",
        title="Named Properties",
    )
    source: Optional[str] = Field(
        None,
        description="The source of this log or channel as a data reference; Typically this refers to the raw LogSet, from which this log WKE is generated.",
        title="Source",
    )
    unitKey: Optional[str] = Field(
        None,
        description="The unitKey to be looked up in the 'frameOfReference.units' dictionary to find the self-contained definition.",
        title="Unit",
    )


class DipSetData(BaseModel):
    azimuthReference: Optional[str] = Field(
        None,
        description="Azimuth reference code defining the type of North. Only used for dipSets with azimuth data",
        title="Azimuth Reference Code",
    )
    bulkURI: Optional[str] = Field(
        None, description="bulkURI either URL or URN.", title="bulk URI"
    )
    classification: Optional[str] = Field(
        "Externally Processed LogSet",
        description="The well-known log set classification code.",
        title="Log Set Classification",
    )
    dateCreated: Optional[datetime] = Field(
        None,
        description="The UTC date time of the entity creation",
        title="Creation Date and Time",
    )
    dateModified: Optional[datetime] = Field(
        None,
        description="The UTC date time of the last entity modification",
        title="Last Modification Date and Time",
    )
    elevationReference: Optional[SimpleElevationReference] = None
    externalIds: Optional[List[str]] = Field(
        None,
        description="An array of identities (e.g. some kind if URL to be resolved in an external data store), which links to external realizations of the same entity.",
        title="Array of External IDs",
    )
    name: Optional[str] = Field(
        None, description="The name of this dip set", title="Dip Set Name"
    )
    operation: Optional[str] = Field(
        None, description="The operation which created this entity", title="Operation"
    )
    reference: Optional[Channel] = None
    referenceType: Optional[str] = Field(
        None,
        description="The reference index type of the dip set.",
        title="Reference Type",
    )
    relationships: Optional[Dipsetrelationships] = None
    start: Optional[ValueWithUnit] = None
    step: Optional[ValueWithUnit] = None
    stop: Optional[ValueWithUnit] = None


class Dipset(BaseModel):
    model_config = ConfigDict(extra="forbid")

    acl: Optional[TagDictionary] = Field(
        None,
        description="The access control tags associated with this entity.",
        title="Access Control List",
    )
    ancestry: Optional[LinkList] = Field(
        None,
        description="The links to data, which constitute the inputs.",
        title="Ancestry",
    )
    createTime: Optional[datetime] = Field(
        None,
        description="Timestamp of the time at which initial version of this OSDU resource object was created. Set by the System. The value is a combined date-time string in ISO-8601 given in UTC.",
        title="Resource Object Creation DateTime",
        json_schema_extra=dict(
            example="2020-12-16T11:46:20.163Z",
        ),
    )
    createUser: Optional[str] = Field(
        None,
        description="The user reference, which created the first version of this resource object. Set by the System.",
        title="Resource Object Creation User Reference",
        json_schema_extra=dict(
            example="some-user@some-company-cloud.com",
        ),
    )
    data: Optional[DipSetData] = Field(
        None, description="dipset data", title="Dip Set Data"
    )
    id: Optional[str] = Field(
        None, description="The unique identifier of the dip set", title="Dip Set ID"
    )
    kind: Optional[str] = Field(
        "osdu:wks:dipSet:1.0.0", description="Kind specification", title="Dip Set Kind"
    )
    legal: Optional[AppModelModelCuratedLegal] = Field(
        None, description="The dip-set's legal tags", title="Legal Tags"
    )
    meta: Optional[List[MetaItem]] = Field(
        None,
        description="The meta data section linking the 'unitKey', 'crsKey' to self-contained definitions (persistableReference)",
        title="Frame of Reference Meta Data",
    )
    modifyTime: Optional[datetime] = Field(
        None,
        description="Timestamp of the time at which this version of the OSDU resource object was created. Set by the System. The value is a combined date-time string in ISO-8601 given in UTC.",
        title="Resource Object Version Creation DateTime",
        json_schema_extra=dict(
            example="2020-12-16T11:52:24.477Z",
        ),
    )
    modifyUser: Optional[str] = Field(
        None,
        description="The user reference, which created this version of this resource object. Set by the System.",
        title="Resource Object Version Creation User Reference",
        json_schema_extra=dict(
            example="some-user@some-company-cloud.com",
        ),
    )
    tags: Optional[Dict[str, Tags]] = Field(
        None,
        description="A generic dictionary of string keys mapping to string value. Only strings are permitted as keys and values.",
        title="Tag Dictionary",
        json_schema_extra=dict(
            example={"NameOfKey": "String value"},
        ),
    )
    type: Optional[str] = Field(
        None,
        description="The reference entity type as declared in common:metadata:entity:*.",
        title="Entity Type",
    )
    version: Optional[float] = Field(
        None,
        description="The version number of this dip set; set by the framework.",
        title="Entity Version Number",
    )


class GeometryItem(BaseModel):
    model_config = ConfigDict(extra="forbid")

    bbox: Optional[List[float]] = Field(None, title="Bbox")
    geometries: List[
        Union[
            GeoJsonPoint,
            GeoJsonMultiPoint,
            GeoJsonLineString,
            GeoJsonMultiLineString,
            Polygon,
            GeoJsonMultiPolygon,
        ]
    ] = Field(..., title="Geometries")
    type: Type


class LogSetData(BaseModel):
    azimuthReference: Optional[str] = Field(
        None,
        description="Azimuth reference code defining the type of North. Only used for logSets with azimuth data",
        title="Azimuth Reference Code",
    )
    channelMnemonics: Optional[List[str]] = Field(
        None,
        description="A list of channel Mnemonics in this log set.",
        title="Channel Mnemonics",
    )
    channelNames: Optional[List[str]] = Field(
        None,
        description="A list of channel long names in this log set.",
        title="Channel Names",
    )
    classification: Optional[str] = Field(
        "Externally Processed LogSet",
        description="The well-known log set classification code.",
        title="Log Set Classification",
    )
    dateCreated: Optional[datetime] = Field(
        None,
        description="The UTC date time of the entity creation",
        title="Creation Date and Time",
    )
    dateModified: Optional[datetime] = Field(
        None,
        description="The UTC date time of the last entity modification",
        title="Last Modification Date and Time",
    )
    elevationReference: Optional[SimpleElevationReference] = None
    externalIds: Optional[List[str]] = Field(
        None,
        description="An array of identities (e.g. some kind if URL to be resolved in an external data store), which links to external realizations of the same entity.",
        title="Array of External IDs",
    )
    name: Optional[str] = Field(
        None, description="The name of this log set", title="Log Set Name"
    )
    operation: Optional[str] = Field(
        None, description="The operation which created this entity", title="Operation"
    )
    reference: Optional[Channel] = None
    referenceType: Optional[str] = Field(
        None,
        description="The reference index type of the log set.",
        title="Reference Type",
    )
    relationships: Optional[Logsetrelationships] = None
    start: Optional[ValueWithUnit] = None
    step: Optional[ValueWithUnit] = None
    stop: Optional[ValueWithUnit] = None


class Logchannel(BaseModel):
    model_config = ConfigDict(extra="forbid")

    bulkURI: Optional[str] = Field(
        None, description="bulkURI either URL or URN.", title="bulk URI"
    )
    columnNames: Optional[List[str]] = Field(
        None,
        description="A list of names for multi-dimensional logs (dimension>1). The length of this array is expected to be equal to 'dimension'. For one-dimensional this property stays empty as the columnName is by definition the log name.",
        title="Column Names",
    )
    dataType: Optional[DataType2] = Field(
        "number",
        description="The log value type (per log sample). The 'format' property may contain further hints about data type presentation.",
        title="Data Type",
    )
    dimension: Optional[int] = Field(
        None, description="The dimension of this log or channel", title="Dimension"
    )
    family: Optional[str] = Field(
        None,
        description="The log family code of this log or channel (optional)",
        title="Log Family",
    )
    familyType: Optional[str] = Field(
        None,
        description="The log family type code of this log or channel. Example: 'Neutron Porosity' for 'Thermal Neutron Porosity Sandstone'. (optional)",
        title="Log Family Type",
    )
    format: Optional[Format2] = Field(
        "float32",
        description="Optional format hint how to treat the log values as strings or number of bits per 'dataType'.",
        title="Format Hint",
    )
    logstoreId: Optional[float] = Field(
        None,
        description="The unique id of this log or channel in the Logstore. This property is not present in the index channel.",
        title="Logstore ID",
    )
    longName: Optional[str] = Field(
        None, description="The long name of this log or channel", title="Log Long Name"
    )
    mnemonic: Optional[str] = Field(
        None, description="The mnemonic of this log or channel", title="Mnemonic"
    )
    name: Optional[str] = Field(
        None, description="The name of this log or channel.", title="Log Name"
    )
    properties: Optional[List[NamedProperty]] = Field(
        None,
        description="The named properties of this log or channel.",
        title="Named Properties",
    )
    source: Optional[str] = Field(
        None,
        description="The source of this log or channel as a data reference; Typically this refers to the raw LogSet, from which this log WKE is generated.",
        title="Source",
    )
    unitKey: Optional[str] = Field(
        None,
        description="The unitKey to be looked up in the 'frameOfReference.units' dictionary to find the self-contained definition.",
        title="Unit",
    )


class Logset(BaseModel):
    model_config = ConfigDict(extra="forbid")

    acl: Optional[TagDictionary] = Field(
        None,
        description="The access control tags associated with this entity.",
        title="Access Control List",
    )
    ancestry: Optional[LinkList] = Field(
        None,
        description="The links to data, which constitute the inputs.",
        title="Ancestry",
    )
    createTime: Optional[datetime] = Field(
        None,
        description="Timestamp of the time at which initial version of this OSDU resource object was created. Set by the System. The value is a combined date-time string in ISO-8601 given in UTC.",
        title="Resource Object Creation DateTime",
        json_schema_extra=dict(
            example="2020-12-16T11:46:20.163Z",
        ),
    )
    createUser: Optional[str] = Field(
        None,
        description="The user reference, which created the first version of this resource object. Set by the System.",
        title="Resource Object Creation User Reference",
        json_schema_extra=dict(
            example="some-user@some-company-cloud.com",
        ),
    )
    data: Optional[LogSetData] = Field(
        None,
        description="Log channel set associated with a wellbore",
        title="Log Set Data",
    )
    id: Optional[str] = Field(
        None, description="The unique identifier of the log set", title="Log Set ID"
    )
    kind: Optional[str] = Field(
        "osdu:wks:logSet:0.0.1", description="Kind specification", title="Log Set Kind"
    )
    legal: Optional[AppModelModelCuratedLegal] = Field(
        None, description="The log-set's legal tags", title="Legal Tags"
    )
    meta: Optional[List[MetaItem]] = Field(
        None,
        description="The meta data section linking the 'unitKey', 'crsKey' to self-contained definitions (persistableReference)",
        title="Frame of Reference Meta Data",
    )
    modifyTime: Optional[datetime] = Field(
        None,
        description="Timestamp of the time at which this version of the OSDU resource object was created. Set by the System. The value is a combined date-time string in ISO-8601 given in UTC.",
        title="Resource Object Version Creation DateTime",
        json_schema_extra=dict(
            example="2020-12-16T11:52:24.477Z",
        ),
    )
    modifyUser: Optional[str] = Field(
        None,
        description="The user reference, which created this version of this resource object. Set by the System.",
        title="Resource Object Version Creation User Reference",
        json_schema_extra=dict(
            example="some-user@some-company-cloud.com",
        ),
    )
    tags: Optional[Dict[str, Tags]] = Field(
        None,
        description="A generic dictionary of string keys mapping to string value. Only strings are permitted as keys and values.",
        title="Tag Dictionary",
        json_schema_extra=dict(
            example={"NameOfKey": "String value"},
        ),
    )
    type: Optional[str] = Field(
        None,
        description="The reference entity type as declared in common:metadata:entity:*.",
        title="Entity Type",
    )
    version: Optional[float] = Field(
        None,
        description="The version number of this log set; set by the framework.",
        title="Entity Version Number",
    )


class GeoJsonFeature(BaseModel):
    model_config = ConfigDict(extra="forbid")

    bbox: Optional[List[float]] = Field(None, title="Bbox")
    geometry: Union[
        GeoJsonPoint,
        GeoJsonMultiPoint,
        GeoJsonLineString,
        GeoJsonMultiLineString,
        Polygon,
        GeoJsonMultiPolygon,
        GeometryItem,
    ] = Field(..., title="Geometry")
    properties: Dict[str, Any] = Field(..., title="Properties")
    type: Type1


class GeoJsonFeatureCollection(BaseModel):
    model_config = ConfigDict(extra="forbid")

    bbox: Optional[List[float]] = Field(None, title="Bbox")
    features: List[GeoJsonFeature] = Field(..., title="Features")
    type: Type2


class LogData(BaseModel):
    azimuthReference: Optional[str] = Field(
        None,
        description="Only supplied with azimuth logs: the azimuth reference code defining the type of North, default TN for true north.",
        title="Azimuth Reference Code",
    )
    dateCreated: Optional[datetime] = Field(
        None,
        description="The UTC date time of the entity creation",
        title="Creation Date and Time",
    )
    dateModified: Optional[datetime] = Field(
        None,
        description="The UTC date time of the last entity modification",
        title="Last Modification Date and Time",
    )
    elevationReference: Optional[SimpleElevationReference] = Field(
        None,
        description="The wellbore's elevation reference from mean sea level (MSL), positive above MSL. This is where the index, e.g. MD == 0 and TVD == 0.",
        title="Elevation Reference",
    )
    externalIds: Optional[List[str]] = Field(
        None,
        description="An array of identities (e.g. some kind if URL to be resolved in an external data store), which links to external realizations of the same entity.",
        title="Array of External IDs",
    )
    history: Optional[List[HistoryRecord]] = Field(
        None,
        description="An array of historyRecords describing the context for the log's creation or processing.",
        title="History Records",
    )
    log: Optional[Logchannel] = Field(
        None,
        description="The log containing the log meta data and log-store reference.",
        title="Log Channel",
    )
    name: Optional[str] = Field(
        None, description="The name of this log set", title="Log Set Name"
    )
    operation: Optional[str] = Field(
        None, description="The operation which created this Log", title="Operation"
    )
    reference: Optional[Logchannel] = Field(
        None,
        description="The reference index - only populated for logs, which are member of a logSet and share the reference index.",
        title="Reference Index",
    )
    referenceType: Optional[ReferenceType] = Field(
        None, description="The reference index type of the log set.", title="Index Type"
    )
    relationships: Optional[LogRelationships] = Field(
        None, description="The related entities.", title="Relationships"
    )
    start: Optional[ValueWithUnit] = Field(
        None, description="The start index value of the log set.", title="Start"
    )
    step: Optional[ValueWithUnit] = Field(
        None,
        description="The index increment value of the log set. Only populated if the log is regularly sampled.",
        title="Step",
    )
    stop: Optional[ValueWithUnit] = Field(
        None, description="The stop index value of the log set.", title="Stop"
    )


class MarkerData(BaseModel):
    age: Optional[ValueWithUnit] = Field(
        None,
        description="The absolute age at the feature boundary. The unit definition is found via the property's unitKey' in 'frameOfReference.units' dictionary.",
        title="Age",
    )
    boundaryRelation: Optional[str] = Field(
        None,
        description="The marker boundary relationship classification",
        title="Interface Boundary Relation",
    )
    classification: Optional[str] = Field(
        None,
        description="The classification of the marker. Could be client-defined via a catalog, e.g. common:wke:markerClassification:1.0.0 and common:wke:markerClassificationMember:1.0.0",
        title="Marker Classification",
    )
    dateCreated: Optional[datetime] = Field(
        None,
        description="The UTC date time of the entity creation",
        title="Creation Date and Time",
    )
    dateModified: Optional[datetime] = Field(
        None,
        description="The UTC date time of the last entity modification",
        title="Last Modification Date and Time",
    )
    depth: Optional[ValueWithUnit] = Field(
        None,
        description="The original marker depth - measured from data.elevationReference in data.depthReferenceType. The unit definition is found via the property's unitKey' in 'frameOfReference.units' dictionary.",
        title="Marker Depth",
    )
    depthReferenceType: Optional[str] = Field(
        "MD",
        description="Depth reference code defining the type of depth for the marker. Default MD (measured depth). Depth is downwards increasing.",
        title="Depth Reference Code",
    )
    elevationReference: Optional[SimpleElevationReference] = Field(
        None,
        description="The elevation from mean sea level (MSL), where depth, topDepth, baseDepth are zero. Values above MSL are positive.",
        title="Elevation Reference Level",
    )
    externalIds: Optional[List[str]] = Field(
        None,
        description="An array of identities (e.g. some kind if URL to be resolved in an external data store), which links to external realizations of the same entity.",
        title="Array of External IDs",
    )
    interpreter: Optional[str] = Field(
        None,
        description="The name of the interpreter who picked this marker.",
        title="Interpreter Name",
    )
    locationWGS84: Optional[GeoJsonFeatureCollection] = Field(
        None,
        description="The marker's shape as GeoJSON Point.",
        title="GeoJSON Marker Location",
    )
    markerFeatureType: Optional[str] = Field(
        None,
        description="The marker's type of feature like 'seismic', 'structural', 'stratigraphic'",
        title="Marker Feature Type",
    )
    markerGeoDomain: Optional[str] = Field(
        None,
        description="The marker's GeoScience domain like 'geologic', 'reservoir', 'petrophysical'",
        title="Marker GeoScience Domain",
    )
    markerSubFeatureAttribute: Optional[str] = Field(
        None,
        description="Further specification of the marker's sub-feature, e.g. in sequence stratigraphy.",
        title="Marker Sub-feature Attribute",
    )
    markerSubFeatureType: Optional[str] = Field(
        None,
        description="The marker's sub-type of the feature like 'horizon', 'fault', 'fracture'",
        title="Marker Sub-feature Type",
    )
    md: ValueWithUnit = Field(
        ...,
        description="The marker measured depth (MD) measured from data.elevationReference. The unit definition is found via the property's unitKey' in 'frameOfReference.units' dictionary.",
        title="Marker Measured Depth",
    )
    name: str = Field(..., description="The name of the marker", title="Marker Name")
    planeOrientationAzimuth: Optional[ValueWithUnit] = Field(
        None,
        description="Azimuth angle. The azimuth reference is given by data.azimuthReference. The 'planeOrientationAzimuth.unitKey' is to be looked up in the 'frameOfReference.units' dictionary to find the self-contained definition.",
        title="Azimuth Angle",
    )
    planeOrientationDip: Optional[ValueWithUnit] = Field(
        None,
        description="Dip angle. The 'planeOrientationDip.unitKey' is to be looked up in the 'frameOfReference.units' dictionary to find the self-contained definition.",
        title="Dip Angle",
    )
    relationships: Optional[Markerrelationships] = Field(
        None, description="The entities related to this marker.", title="Relationships"
    )
    stratigraphicHierarchyLevel: Optional[int] = Field(
        None,
        description="Optional hierarchical level in the chrono-stratigraphic/litho-stratigraphic catalog table, identified by the data.relationships.chartId",
        title="Column Level",
    )
    tvd: Optional[ValueWithUnit] = Field(
        None,
        description="The marker true vertical depth (TVD) measured from data.elevationReference. The unit definition is found via the property's unitKey' in 'frameOfReference.units' dictionary.",
        title="Marker Measured Depth",
    )
    wgs84ElevationFromMsl: Optional[ValueWithUnit] = Field(
        None,
        description="Elevation from Mean Sea Level, downwards negative. The unit definition is found via the property's unitKey' in 'frameOfReference.units' dictionary.",
        title="Elevation from MSL",
    )
    wgs84LatitudeLongitude: Optional[CoreDlGeopoint] = Field(
        None,
        description="The marker's position in WGS 84 latitude and longitude.",
        title="WGS 84 Latitude Longitude",
    )


class TrajectoryData(BaseModel):
    azimuthReference: Optional[str] = Field(
        None,
        description="Azimuth reference code defining the type of North, default TN for true north.",
        title="Azimuth Reference Code",
    )
    channelMnemonics: Optional[List[str]] = Field(
        None,
        description="A list of channel Mnemonics in this trajectory.",
        title="Channel Mnemonics",
    )
    channelNames: Optional[List[str]] = Field(
        None,
        description="A list of channel long names in this trajectory.",
        title="Channel Names",
    )
    channels: Optional[List[Trajectorychannel]] = Field(
        None, description="The channels associated to the index.", title="Channels"
    )
    classification: Optional[str] = Field(
        "Raw Deviation Survey",
        description="The well-known trajectory classification code.",
        title="Trajectory Classification",
    )
    dateCreated: Optional[datetime] = Field(
        None,
        description="The UTC date time of the entity creation",
        title="Creation Date and Time",
    )
    dateModified: Optional[datetime] = Field(
        None,
        description="The UTC date time of the last entity modification",
        title="Last Modification Date and Time",
    )
    elevationReference: Optional[SimpleElevationReference] = Field(
        None,
        description="The wellbore's elevation reference from mean sea level (MSL), positive above MSL. This is where MD == 0 and TVD == 0",
        title="Elevation Reference",
    )
    externalIds: Optional[List[str]] = Field(
        None,
        description="An array of identities (e.g. some kind if URL to be resolved in an external data store), which links to external realizations of the same entity.",
        title="Array of External IDs",
    )
    index: Optional[Trajectorychannel] = Field(
        None, description="The index channel or log.", title="Index Channel"
    )
    indexType: Optional[str] = Field(
        None, description="The index type of the trajectory.", title="Index Type"
    )
    locationWGS84: Optional[GeoJsonFeatureCollection] = Field(
        None,
        description="The wellbore's trajectory preview shape as GeoJSON LineString.",
        title="Trajectory preview",
    )
    name: Optional[str] = Field(
        None, description="The name of this trajectory", title="Trajectory Name"
    )
    referencePosition: Optional[Point3dNonGeoJson] = Field(
        None,
        description="The 3D reference position for the first sample (surface location for main wellbores, tie-in point for side-tracks.",
        title="Reference Position First Sample",
    )
    relationships: Optional[Trajectoryrelationships] = Field(
        None, description="The related entities.", title="Relationships"
    )
    start: Optional[float] = Field(
        None, description="The start index value of the trajectory.", title="Start"
    )
    step: Optional[float] = Field(
        None, description="The index increment value of the trajectory.", title="Step"
    )
    stop: Optional[float] = Field(
        None, description="The stop index value of the trajectory.", title="Stop"
    )
    wellHeadWgs84: Optional[Wgs84Position] = Field(
        None,
        description="The wellbore's position in WGS 84 latitude and longitude; vertical position is an elevation from mean sea level (MSL), positive above MSL.",
        title="WGS 84 Position",
    )


class WellData(BaseModel):
    basinContext: Optional[BasinContext] = Field(
        None,
        description="The basin context details for the well.",
        title="Basin Context",
    )
    block: Optional[str] = Field(
        None, description="The block name, in which the well is located.", title="Block"
    )
    country: Optional[str] = Field(
        None,
        description="The country, in which the well is located. The country name follows the convention in ISO 3166-1 'English short country name', see https://en.wikipedia.org/wiki/ISO_3166-1",
        title="Country",
    )
    county: Optional[str] = Field(
        None,
        description="The county name, in which the well is located.",
        title="County",
    )
    dateCreated: Optional[datetime] = Field(
        None,
        description="The UTC date time of the entity creation",
        title="Creation Date and Time",
    )
    dateLicenseIssued: Optional[datetime] = Field(
        None,
        description="The UTC date time when the well license was issued.",
        title="License Issue Date",
    )
    dateModified: Optional[datetime] = Field(
        None,
        description="The UTC date time of the last entity modification",
        title="Last Modification Date and Time",
    )
    datePluggedAbandoned: Optional[datetime] = Field(
        None,
        description="The UTC date and time at which the well was plugged and abandoned.",
        title="Plugged Abandoned Date",
    )
    dateSpudded: Optional[datetime] = Field(
        None,
        description="The date and time when activities to drill the borehole begin to create a hole in the earth. For a sidetrack, this is the date kickoff operations began. The format follows ISO 8601 YYYY-MM-DD extended format",
        title="Spud Date",
    )
    directionWell: Optional[DirectionWell] = Field(
        None,
        description="POSC well direction. The direction of the flow of the fluids in a well facility (generally, injected or produced, or some combination).",
        title="Well Direction",
    )
    district: Optional[str] = Field(
        None,
        description="The district name, to which the well belongs.",
        title="District",
    )
    elevationReference: Optional[SimpleElevationReference] = Field(
        None,
        description="The well's elevation reference from mean sea level (MSL), positive above MSL. This is where MD == 0 and TVD == 0",
        title="Elevation Reference",
    )
    externalIds: Optional[List[str]] = Field(
        None,
        description="An array of identities (e.g. some kind if URL to be resolved in an external data store), which links to external realizations of the same entity.",
        title="Array of External IDs",
    )
    field: Optional[str] = Field(
        None, description="The field name, to which the well belongs.", title="Field"
    )
    fluidWell: Optional[FluidWell] = Field(
        None,
        description="POSC well fluid. The type of fluid being produced from or injected \\ninto a well facility.",
        title="Well Fluid",
    )
    groundElevation: Optional[ValueWithUnit] = Field(
        None,
        description="The well's ground elevation, Values above MSL are positive..",
        title="Ground Elevation",
    )
    locationWGS84: Optional[GeoJsonFeatureCollection] = Field(
        None,
        description="A 2D GeoJSON FeatureCollection defining well location or trajectory in WGS 84 CRS.",
        title="Well Shape WGS 84",
    )
    name: Optional[str] = Field(None, description="The well name", title="Well Name")
    operator: Optional[str] = Field(
        None,
        description="The operator company name of the well.",
        title="Well Operator",
    )
    operatorDivision: Optional[str] = Field(
        None,
        description="The operator division of the well.",
        title="Operator Division",
    )
    operatorInterest: Optional[float] = Field(
        None,
        description="Interest for operator. Commonly in percent.",
        title="Well Operator Interest",
    )
    operatorOriginal: Optional[str] = Field(
        None,
        description="Original operator of the well. This may be different than the current operator.",
        title="Original Well Operator",
    )
    plssLocation: Optional[PlssLocation] = Field(
        None,
        description="A location described by the Public Land Survey System (United States)",
        title="US PLSS Location",
    )
    propertyDictionary: Optional[Dict[str, Any]] = Field(
        None,
        description="A dictionary structure, i.e. key/string value pairs, to carry additional well properties.",
        title="Property Dictionary",
    )
    region: Optional[str] = Field(
        None,
        description="Geo-political region in which the well is located.",
        title="Region",
    )
    relationships: Optional[Wellrelationships] = Field(
        None, description="The related entities.", title="Relationships"
    )
    state: Optional[str] = Field(
        None, description="The state name, in which the well is located.", title="State"
    )
    uwi: Optional[str] = Field(
        None,
        description="The unique well identifier, aka. API number, US well number or UBHI. Codes can have 10, 12 or 14 digits depending on the availability of directional sidetrack (2 digits) and event sequence codes (2 digits).",
        title="Unique Well Identifier",
    )
    waterDepth: Optional[ValueWithUnit] = Field(
        None, description="Depth of water (not land rigs).", title="Water Depth"
    )
    wellHeadElevation: Optional[ValueWithUnit] = Field(
        None,
        description="The well's vertical position is an elevation from mean sea level (MSL), positive above MSL.",
        title="Well Head Elevation",
    )
    wellHeadGeographic: Optional[GeographicPosition] = Field(
        None,
        description="The well's well head position in the native, geographic CRS; vertical position is an elevation from mean sea level (MSL), positive above MSL.",
        title="Well Head Position, Geographic",
    )
    wellHeadProjected: Optional[ProjectedPosition] = Field(
        None,
        description="The well's well head position in the native, projected CRS; vertical position is an elevation from mean sea level (MSL), positive above MSL.",
        title="Well Head Position, Projected",
    )
    wellHeadWgs84: Optional[CoreDlGeopoint] = Field(
        None,
        description="The well's position in WGS 84 latitude and longitude.",
        title="WGS 84 Position",
    )
    wellLocationType: Optional[WellLocationType] = None
    wellNumberGovernment: Optional[str] = Field(
        None, description="Government assigned well number.", title="Government Number"
    )
    wellNumberLicense: Optional[str] = Field(
        None, description="License number of the well.", title="Well License Number"
    )
    wellNumberOperator: Optional[str] = Field(
        None, description="Operator well number.", title="Operator Number"
    )
    wellPurpose: Optional[WellPurpose] = Field(
        None, description="POSC well purpose", title="Well Purpose"
    )
    wellStatus: Optional[WellStatus] = Field(
        None, description="POSC well status.", title="Well Status"
    )
    wellType: Optional[WellType] = Field(
        None, description="Type of well.", title="Well Type"
    )


class WellboreData(BaseModel):
    airGap: Optional[ValueWithUnit] = Field(
        None,
        description="The gap between water surface and offshore drilling platform.",
        title="Air Gap",
    )
    block: Optional[str] = Field(
        None,
        description="The block name, in which the wellbore is located.",
        title="Block",
    )
    country: Optional[str] = Field(
        None,
        description="The country, in which the wellbore is located. The country name follows the convention in ISO 3166-1 'English short country name', see https://en.wikipedia.org/wiki/ISO_3166-1",
        title="Country",
    )
    county: Optional[str] = Field(
        None,
        description="The county name, in which the wellbore is located.",
        title="County",
    )
    dateCreated: Optional[datetime] = Field(
        None,
        description="The UTC date time of the entity creation",
        title="Creation Date and Time",
    )
    dateModified: Optional[datetime] = Field(
        None,
        description="The UTC date time of the last entity modification",
        title="Last Modification Date and Time",
    )
    drillingDaysTarget: Optional[ValueWithUnit] = Field(
        None,
        description="Target days for drilling wellbore.",
        title="Target Drilling Days",
    )
    elevationReference: Optional[SimpleElevationReference] = Field(
        None,
        description="The wellbore's elevation reference from mean sea level (MSL), positive above MSL. This is where MD == 0 and TVD == 0",
        title="Elevation Reference",
    )
    externalIds: Optional[List[str]] = Field(
        None,
        description="An array of identities (e.g. some kind if URL to be resolved in an external data store), which links to external realizations of the same entity.",
        title="Array of External IDs",
    )
    field: Optional[str] = Field(
        None,
        description="The field name, to which the wellbore belongs.",
        title="Field",
    )
    formationAtTd: Optional[str] = Field(
        None,
        description="The name of the formation at the wellbore's total depth.",
        title="Formation at TD",
    )
    formationProjected: Optional[str] = Field(
        None,
        description="The name of the formation at the wellbore's projected depth. This property is questionable as there is not precise documentation available.",
        title="Formation Projected",
    )
    hasAchievedTotalDepth: Optional[bool] = Field(
        True,
        description='True ("true" of "1") indicates that the wellbore has acheieved total depth. That is, drilling has completed. False ("false" or "0") indicates otherwise. Not given indicates that it is not known whether total depth has been reached.',
        title="Has Total Depth Been Achieved Flag",
    )
    isActive: Optional[bool] = Field(
        None,
        description='True (="1" or "true") indicates that the wellbore is active. False (="0" or "false") indicates otherwise. It is the servers responsibility to set this value based on its available internal data (e.g., what objects are changing).',
        title="Is Active Flag",
    )
    kickOffMd: Optional[ValueWithUnit] = Field(
        None,
        description="The kick-off point in measured depth (MD); for the main well the kickOffMd is set to 0.",
        title="Kick-off MD",
    )
    kickOffTvd: Optional[ValueWithUnit] = Field(
        None,
        description="Kickoff true vertical depth of the wellbore; for the main wellbore the kickOffMd is set to 0.",
        title="Kick-off MD",
    )
    locationWGS84: Optional[GeoJsonFeatureCollection] = Field(
        None,
        description="A 2D GeoJSON FeatureCollection defining wellbore location or trajectory in WGS 84 CRS.",
        title="Wellbore Shape WGS 84",
    )
    name: Optional[str] = Field(
        None, description="The wellbore name", title="Wellbore Name"
    )
    operator: Optional[str] = Field(
        None, description="The operator of the wellbore.", title="Operator"
    )
    permitDate: Optional[date] = Field(
        None, description="The wellbore's permit date.", title="Permit Date"
    )
    permitNumber: Optional[str] = Field(
        None,
        description="The wellbore's permit number or permit ID.",
        title="Permit Number",
    )
    plssLocation: Optional[PlssLocation] = Field(
        None,
        description="A location described by the Public Land Survey System (United States)",
        title="US PLSS Location",
    )
    propertyDictionary: Optional[Dict[str, Any]] = Field(
        None,
        description="A dictionary structure, i.e. key/string value pairs, to carry additional wellbore properties.",
        title="Property Dictionary",
    )
    relationships: Optional[Wellborerelationships] = Field(
        None, description="The related entities.", title="Relationships"
    )
    shape: Optional[Shape] = Field(
        None, description="POSC wellbore trajectory shape.", title="Wellbore Shape"
    )
    spudDate: Optional[date] = Field(
        None,
        description="The date and time when activities to drill the borehole begin to create a hole in the earth. For a sidetrack, this is the date kickoff operations began. The format follows ISO 8601 YYYY-MM-DD extended format",
        title="Spud Date",
    )
    state: Optional[str] = Field(
        None,
        description="The state name, in which the wellbore is located.",
        title="State",
    )
    totalDepthMd: Optional[ValueWithUnit] = Field(
        None,
        description="The measured depth of the borehole. If status is plugged, indicates the maximum depth reached before plugging. It is recommended that this value be updated about every 10 minutes by an assigned raw data provider at a site.",
        title="Total MD",
    )
    totalDepthMdDriller: Optional[ValueWithUnit] = Field(
        None,
        description="The total depth along the wellbore as reported by the drilling contractor from 'elevationReference'. The unit definition is found via the property's unitKey' in 'frameOfReference.units' dictionary..",
        title="Total MD Drilled",
    )
    totalDepthMdPlanned: Optional[ValueWithUnit] = Field(
        None,
        description="Planned measured depth for the wellbore total depth.",
        title="Total MD Planned",
    )
    totalDepthMdSubSeaPlanned: Optional[ValueWithUnit] = Field(
        None,
        description="Planned measured for the wellbore total depth - with respect to seabed.",
        title="Total MD Sub Sea Planned",
    )
    totalDepthProjectedMd: Optional[ValueWithUnit] = Field(
        None,
        description="The projected total measured depth of the borehole. This property is questionable as there is not precise documentation available.",
        title="Total MD Projected",
    )
    totalDepthTvd: Optional[ValueWithUnit] = Field(
        None,
        description="The true vertical depth of the borehole. If status is plugged, indicates the maximum depth reached before plugging. It is recommended that this value be updated about every 10 minutes by an assigned raw data provider at a site.",
        title="Total TVD",
    )
    totalDepthTvdDriller: Optional[ValueWithUnit] = Field(
        None,
        description="The total depth true vertical as reported by the drilling contractor from 'elevationReference', Downwards increasing. The unit definition is found via the property's unitKey' in 'frameOfReference.units' dictionary.",
        title="Total TVD Drilled",
    )
    totalDepthTvdPlanned: Optional[ValueWithUnit] = Field(
        None,
        description="Planned true vertical depth for the wellbore total depth.",
        title="Total TVD Planned",
    )
    totalDepthTvdSubSeaPlanned: Optional[ValueWithUnit] = Field(
        None,
        description="Planned true vertical depth for the wellbore total depth - with respect to seabed.",
        title="Total TVD Sub Sea Planned",
    )
    uwi: Optional[str] = Field(
        None,
        description="The unique wellbore identifier, aka. API number, US well number or UBHI. Codes can have 10, 12 or 14 digits depending on the availability of directional sidetrack (2 digits) and event sequence codes (2 digits).",
        title="Unique Wellbore Identifier",
    )
    wellHeadElevation: Optional[ValueWithUnit] = Field(
        None,
        description="The wellbore's vertical position is an elevation from mean sea level (MSL), positive above MSL.",
        title="Well Head Elevation",
    )
    wellHeadGeographic: Optional[GeographicPosition] = Field(
        None,
        description="The wellbore's well head position in the native, geographic CRS; vertical position is an elevation from mean sea level (MSL), positive above MSL.",
        title="Well Head Position, Geographic",
    )
    wellHeadProjected: Optional[ProjectedPosition] = Field(
        None,
        description="The wellbore's well head position in the native, projected CRS; vertical position is an elevation from mean sea level (MSL), positive above MSL.",
        title="Well Head Position, Projected",
    )
    wellHeadWgs84: Optional[CoreDlGeopoint] = Field(
        None,
        description="The wellbore's position in WGS 84 latitude and longitude.",
        title="WGS 84 Position",
    )
    wellboreNumberGovernment: Optional[str] = Field(
        None,
        description="Government assigned wellbore number.",
        title="Government Number",
    )
    wellboreNumberOperator: Optional[str] = Field(
        None, description="Operator wellbore number.", title="Operator Number"
    )
    wellborePurpose: Optional[WellborePurpose] = Field(
        None, description="POSC wellbore purpose", title="Wellbore Purpose"
    )
    wellboreStatus: Optional[WellboreStatus] = Field(
        None, description="POSC wellbore status.", title="Wellbore Status"
    )
    wellboreType: Optional[WellboreType] = Field(
        None, description="Type of wellbore.", title="Wellbore Type"
    )


class Log(BaseModel):
    model_config = ConfigDict(extra="forbid")

    acl: Optional[TagDictionary] = Field(
        None,
        description="The access control tags associated with this entity.",
        title="Access Control List",
    )
    ancestry: Optional[LinkList] = Field(
        None,
        description="The links to data, which constitute the inputs.",
        title="Ancestry",
    )
    createTime: Optional[datetime] = Field(
        None,
        description="Timestamp of the time at which initial version of this OSDU resource object was created. Set by the System. The value is a combined date-time string in ISO-8601 given in UTC.",
        title="Resource Object Creation DateTime",
        json_schema_extra=dict(
            example="2020-12-16T11:46:20.163Z",
        ),
    )
    createUser: Optional[str] = Field(
        None,
        description="The user reference, which created the first version of this resource object. Set by the System.",
        title="Resource Object Creation User Reference",
        json_schema_extra=dict(
            example="some-user@some-company-cloud.com",
        ),
    )
    data: Optional[LogData] = Field(
        None, description="Log data associated with a wellbore", title="Log Data"
    )
    id: Optional[str] = Field(
        None, description="The unique identifier of the log", title="Log Set ID"
    )
    kind: Optional[str] = Field(
        "osdu:wks:log:0.0.1", description="Kind specification", title="Log Kind"
    )
    legal: Optional[AppModelModelCuratedLegal] = Field(
        None, description="The log's legal tags", title="Legal Tags"
    )
    meta: Optional[List[MetaItem]] = Field(
        None,
        description="The meta data section linking the 'unitKey', 'crsKey' to self-contained definitions (persistableReference)",
        title="Frame of Reference Meta Data",
    )
    modifyTime: Optional[datetime] = Field(
        None,
        description="Timestamp of the time at which this version of the OSDU resource object was created. Set by the System. The value is a combined date-time string in ISO-8601 given in UTC.",
        title="Resource Object Version Creation DateTime",
        json_schema_extra=dict(
            example="2020-12-16T11:52:24.477Z",
        ),
    )
    modifyUser: Optional[str] = Field(
        None,
        description="The user reference, which created this version of this resource object. Set by the System.",
        title="Resource Object Version Creation User Reference",
        json_schema_extra=dict(
            example="some-user@some-company-cloud.com",
        ),
    )
    status: Optional[str] = Field(
        "compliant", description="The status of this log", title="Entity Status"
    )
    tags: Optional[Dict[str, Tags]] = Field(
        None,
        description="A generic dictionary of string keys mapping to string value. Only strings are permitted as keys and values.",
        title="Tag Dictionary",
        json_schema_extra=dict(
            example={"NameOfKey": "String value"},
        ),
    )
    type: Optional[str] = Field(
        None,
        description="The reference entity type as declared in common:metadata:entity:*.",
        title="Entity Type",
    )
    version: Optional[float] = Field(
        None,
        description="The version number of this log; set by the framework.",
        title="Entity Version Number",
    )


class Marker(BaseModel):
    model_config = ConfigDict(extra="forbid")

    acl: TagDictionary = Field(
        ...,
        description="The access control tags associated with this entity.",
        title="Access Control List",
    )
    ancestry: Optional[LinkList] = Field(
        None,
        description="The links to data, which constitute the inputs.",
        title="Ancestry",
    )
    createTime: Optional[datetime] = Field(
        None,
        description="Timestamp of the time at which initial version of this OSDU resource object was created. Set by the System. The value is a combined date-time string in ISO-8601 given in UTC.",
        title="Resource Object Creation DateTime",
        json_schema_extra=dict(
            example="2020-12-16T11:46:20.163Z",
        ),
    )
    createUser: Optional[str] = Field(
        None,
        description="The user reference, which created the first version of this resource object. Set by the System.",
        title="Resource Object Creation User Reference",
        json_schema_extra=dict(
            example="some-user@some-company-cloud.com",
        ),
    )
    data: Optional[MarkerData] = Field(
        None,
        description="Geological marker using a single point-observation, typically along a wellbore.",
        title="Marker Data",
    )
    id: Optional[str] = Field(
        None, description="The unique identifier of the marker", title="Marker ID"
    )
    kind: str = Field(..., description="Marker kind specification", title="Marker Kind")
    legal: AppModelModelCuratedLegal = Field(
        ..., description="The marker's legal tags", title="Legal Tags"
    )
    meta: Optional[List[MetaItem]] = Field(
        None,
        description="The meta data section linking the 'unitKey', 'crsKey' to self-contained definitions (persistableReference)",
        title="Frame of Reference Meta Data",
    )
    modifyTime: Optional[datetime] = Field(
        None,
        description="Timestamp of the time at which this version of the OSDU resource object was created. Set by the System. The value is a combined date-time string in ISO-8601 given in UTC.",
        title="Resource Object Version Creation DateTime",
        json_schema_extra=dict(
            example="2020-12-16T11:52:24.477Z",
        ),
    )
    modifyUser: Optional[str] = Field(
        None,
        description="The user reference, which created this version of this resource object. Set by the System.",
        title="Resource Object Version Creation User Reference",
        json_schema_extra=dict(
            example="some-user@some-company-cloud.com",
        ),
    )
    tags: Optional[Dict[str, Tags]] = Field(
        None,
        description="A generic dictionary of string keys mapping to string value. Only strings are permitted as keys and values.",
        title="Tag Dictionary",
        json_schema_extra=dict(
            example={"NameOfKey": "String value"},
        ),
    )
    type: Optional[str] = Field(
        None,
        description="The reference entity type as declared in common:metadata:entity:*.",
        title="Entity Type",
    )
    version: Optional[float] = Field(
        None,
        description="The version number of this marker; set by the framework.",
        title="Entity Version Number",
    )


class Trajectory(BaseModel):
    model_config = ConfigDict(extra="forbid")

    acl: Optional[TagDictionary] = Field(
        None,
        description="The access control tags associated with this entity.",
        title="Access Control List",
    )
    ancestry: Optional[LinkList] = Field(
        None,
        description="The links to data, which constitute the inputs.",
        title="Ancestry",
    )
    createTime: Optional[datetime] = Field(
        None,
        description="Timestamp of the time at which initial version of this OSDU resource object was created. Set by the System. The value is a combined date-time string in ISO-8601 given in UTC.",
        json_schema_extra=dict(
            example="2020-12-16T11:46:20.163Z",
        ),
        title="Resource Object Creation DateTime",
    )
    createUser: Optional[str] = Field(
        None,
        description="The user reference, which created the first version of this resource object. Set by the System.",
        json_schema_extra=dict(
            example="some-user@some-company-cloud.com",
        ),
        title="Resource Object Creation User Reference",
    )
    data: Optional[TrajectoryData] = Field(
        None,
        description="A log set representing a trajectory associated with a wellbore",
        title="Trajectory Data",
    )
    id: Optional[str] = Field(
        None,
        description="The unique identifier of the trajectory",
        title="Trajectory ID",
    )
    kind: Optional[str] = Field(
        "osdu:wks:trajectory:0.0.1",
        description="Kind specification",
        title="Trajectory Kind",
    )
    legal: Optional[AppModelModelCuratedLegal] = Field(
        None, description="The trajectory's legal tags", title="Legal Tags"
    )
    meta: Optional[List[MetaItem]] = Field(
        None,
        description="The meta data section linking the 'unitKey', 'crsKey' to self-contained definitions (persistableReference)",
        title="Frame of Reference Meta Data",
    )
    modifyTime: Optional[datetime] = Field(
        None,
        description="Timestamp of the time at which this version of the OSDU resource object was created. Set by the System. The value is a combined date-time string in ISO-8601 given in UTC.",
        title="Resource Object Version Creation DateTime",
        json_schema_extra=dict(
            example="2020-12-16T11:52:24.477Z",
        ),
    )
    modifyUser: Optional[str] = Field(
        None,
        description="The user reference, which created this version of this resource object. Set by the System.",
        title="Resource Object Version Creation User Reference",
        json_schema_extra=dict(
            example="some-user@some-company-cloud.com",
        ),
    )
    tags: Optional[Dict[str, Tags]] = Field(
        None,
        description="A generic dictionary of string keys mapping to string value. Only strings are permitted as keys and values.",
        title="Tag Dictionary",
        json_schema_extra=dict(
            example={"NameOfKey": "String value"},
        ),
    )
    type: Optional[str] = Field(
        None,
        description="The reference entity type as declared in common:metadata:entity:*.",
        title="Entity Type",
    )
    version: Optional[float] = Field(
        None,
        description="The version number of this trajectory; set by the framework.",
        title="Entity Version Number",
    )


class Well(BaseModel):
    model_config = ConfigDict(extra="forbid")

    acl: Optional[TagDictionary] = Field(
        None,
        description="The access control tags associated with this entity.",
        title="Access Control List",
    )
    ancestry: Optional[LinkList] = Field(
        None,
        description="The links to data, which constitute the inputs.",
        title="Ancestry",
    )
    createTime: Optional[datetime] = Field(
        None,
        description="Timestamp of the time at which initial version of this OSDU resource object was created. Set by the System. The value is a combined date-time string in ISO-8601 given in UTC.",
        title="Resource Object Creation DateTime",
        json_schema_extra=dict(
            example="2020-12-16T11:46:20.163Z",
        ),
    )
    createUser: Optional[str] = Field(
        None,
        description="The user reference, which created the first version of this resource object. Set by the System.",
        title="Resource Object Creation User Reference",
        json_schema_extra=dict(
            example="some-user@some-company-cloud.com",
        ),
    )
    data: Optional[WellData] = Field(
        None, description="Well data container", title="Well Data"
    )
    id: Optional[str] = Field(
        None, description="The unique identifier of the well", title="Well ID"
    )
    kind: Optional[str] = Field(
        "osdu:wks:well:0.0.1",
        description="Well-known well kind specification",
        title="Well Kind",
    )
    legal: Optional[AppModelModelCuratedLegal] = Field(
        None,
        description="The geological interpretation's legal tags",
        title="Legal Tags",
    )
    meta: Optional[List[MetaItem]] = Field(
        None,
        description="The meta data section linking the 'unitKey', 'crsKey' to self-contained definitions (persistableReference)",
        title="Frame of Reference Meta Data",
    )
    modifyTime: Optional[datetime] = Field(
        None,
        description="Timestamp of the time at which this version of the OSDU resource object was created. Set by the System. The value is a combined date-time string in ISO-8601 given in UTC.",
        title="Resource Object Version Creation DateTime",
        json_schema_extra=dict(
            example="2020-12-16T11:52:24.477Z",
        ),
    )
    modifyUser: Optional[str] = Field(
        None,
        description="The user reference, which created this version of this resource object. Set by the System.",
        title="Resource Object Version Creation User Reference",
        json_schema_extra=dict(
            example="some-user@some-company-cloud.com",
        ),
    )
    tags: Optional[Dict[str, Tags]] = Field(
        None,
        description="A generic dictionary of string keys mapping to string value. Only strings are permitted as keys and values.",
        title="Tag Dictionary",
        json_schema_extra=dict(
            example={"NameOfKey": "String value"},
        ),
    )
    type: Optional[str] = Field(
        None,
        description="The reference entity type as declared in common:metadata:entity:*.",
        title="Entity Type",
    )
    version: Optional[float] = Field(
        None,
        description="The version number of this well; set by the framework.",
        title="Entity Version Number",
    )


class Wellbore(BaseModel):
    model_config = ConfigDict(extra="forbid")

    acl: Optional[TagDictionary] = Field(
        None,
        description="The access control tags associated with this entity.",
        title="Access Control List",
    )
    ancestry: Optional[LinkList] = Field(
        None,
        description="The links to data, which constitute the inputs.",
        title="Ancestry",
    )
    createTime: Optional[datetime] = Field(
        None,
        description="Timestamp of the time at which initial version of this OSDU resource object was created. Set by the System. The value is a combined date-time string in ISO-8601 given in UTC.",
        title="Resource Object Creation DateTime",
        json_schema_extra=dict(
            example="2020-12-16T11:46:20.163Z",
        ),
    )
    createUser: Optional[str] = Field(
        None,
        description="The user reference, which created the first version of this resource object. Set by the System.",
        title="Resource Object Creation User Reference",
        json_schema_extra=dict(
            example="some-user@some-company-cloud.com",
        ),
    )
    data: Optional[WellboreData] = Field(
        None, description="Wellbore data container", title="Wellbore Data"
    )
    id: Optional[str] = Field(
        None, description="The unique identifier of the wellbore", title="Wellbore ID"
    )
    kind: Optional[str] = Field(
        "osdu:wks:wellbore:0.0.1",
        description="Well-known wellbore kind specification",
        title="Wellbore Kind",
    )
    legal: Optional[AppModelModelCuratedLegal] = Field(
        None,
        description="The geological interpretation's legal tags",
        title="Legal Tags",
    )
    meta: Optional[List[MetaItem]] = Field(
        None,
        description="The meta data section linking the 'unitKey', 'crsKey' to self-contained definitions (persistableReference)",
        title="Frame of Reference Meta Data",
    )
    modifyTime: Optional[datetime] = Field(
        None,
        description="Timestamp of the time at which this version of the OSDU resource object was created. Set by the System. The value is a combined date-time string in ISO-8601 given in UTC.",
        title="Resource Object Version Creation DateTime",
        json_schema_extra=dict(
            example="2020-12-16T11:52:24.477Z",
        ),
    )
    modifyUser: Optional[str] = Field(
        None,
        description="The user reference, which created this version of this resource object. Set by the System.",
        title="Resource Object Version Creation User Reference",
        json_schema_extra=dict(
            example="some-user@some-company-cloud.com",
        ),
    )
    tags: Optional[Dict[str, Tags]] = Field(
        None,
        description="A generic dictionary of string keys mapping to string value. Only strings are permitted as keys and values.",
        title="Tag Dictionary",
        json_schema_extra=dict(
            example={"NameOfKey": "String value"},
        ),
    )
    type: Optional[str] = Field(
        None,
        description="The reference entity type as declared in common:metadata:entity:*.",
        title="Entity Type",
    )
    version: Optional[float] = Field(
        None,
        description="The version number of this wellbore; set by the framework.",
        title="Entity Version Number",
    )
